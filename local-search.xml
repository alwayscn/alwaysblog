<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>头脑风暴</title>
    <link href="/alwaysblog/post/2482852438/"/>
    <url>/alwaysblog/post/2482852438/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>头脑风暴</category>
      
    </categories>
    
    
    <tags>
      
      <tag>头脑风暴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github + hexo 搭建个人博客</title>
    <link href="/alwaysblog/post/1613536721/"/>
    <url>/alwaysblog/post/1613536721/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>首先下载稳定版</p><p><a href="https://nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi" rel="external nofollow noreferrer">下载 Node.js</a></p><p>我这里给的是64位的。</p><p>安装选项全部默认，一路点击<code>Next</code>。</p><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><h2 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h2><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre><code class="bash">npm config set registry https://registry.npm.taobao.org</code></pre><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>为了把本地的网页文件上传到 github 上面去，我们需要用到分布式版本控制工具————Git</p><p><a href="https://git-scm.com/download/win" rel="external nofollow noreferrer">下载 Git</a></p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h2 id="注册-Github-账号"><a href="#注册-Github-账号" class="headerlink" title="注册 Github 账号"></a>注册 Github 账号</h2><p>接下来就去注册一个 github 账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开 <a href="%5BGitHub%5D(https://github.com/)"> github </a>, 新建一个项目，输入自己的项目名字，README 初始化也要勾上。</p><p>然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，</p><p>点击那个链接，就会出现自己的网页啦</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开 git 的控制台窗口，以后我们所有的操作都在 git 控制台进行，就不要用 Windows 自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code> 安装 Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开 <a href="https://link.zhihu.com/?target=http://localhost:4000/" rel="external nofollow noreferrer">http://localhost:4000/</a>，就可以看到我们的博客啦</p><p>按<code>ctrl+c</code>关闭本地服务器。</p><p>官网： <a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noreferrer">https://hexo.io/zh-cn/docs/</a></p><h2 id="连接-Github-与本地"><a href="#连接-Github-与本地" class="headerlink" title="连接 Github 与本地"></a>连接 Github 与本地</h2><p>首先右键打开 git bash，然后输入下面命令：</p><pre><code class="bash">git config --global user.name &quot;alwayscn&quot;git config --global user.email &quot;123@yeah.net&quot;</code></pre><p>用户名和邮箱根据你注册 github 的信息自行修改。</p><p>然后生成密钥 SSH key：</p><pre><code class="bash">ssh-keygen -t rsa -C &quot;123@yeah.net&quot;</code></pre><p>打开 <a href="https://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash 中输入</p><pre><code class="bash">cat ~/.ssh/id_rsa.pub</code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改配置：</p><pre><code class="bash"># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: https://alwayscn.github.io/alwaysblog/root: /deploy:   type: git   repository: git@github.com:alwayscn/alwaysblog.git  branch: main</code></pre><p>repository 修改为你自己的 github 项目地址。</p><h2 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开 git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完 markdown 文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到 github 上。这时打开你的主页就能看到发布的文章啦。</p><h2 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h2><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到 github 上面。</p><p>首先在 github 博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git branch -b hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
      <tag>github 博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时光余热</title>
    <link href="/alwaysblog/post/1759737362/"/>
    <url>/alwaysblog/post/1759737362/</url>
    
    <content type="html"><![CDATA[<h2 id="练字总结"><a href="#练字总结" class="headerlink" title="练字总结"></a>练字总结</h2><h3 id="字帖选择"><a href="#字帖选择" class="headerlink" title="字帖选择"></a>字帖选择</h3><ol><li>行楷：<strong>吴玉生</strong>， <strong>荆霄鹏</strong>，田英章</li><li>正楷：卢中南，庞中华</li><li>古贴： 正楷行楷练好，字的框架搭好再去临纂古贴， 古贴要求有观帖能力，推荐 灵飞经， 兰亭集序， 赤壁赋</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charles</title>
    <link href="/alwaysblog/post/4178019943/"/>
    <url>/alwaysblog/post/4178019943/</url>
    
    <content type="html"><![CDATA[<h2 id="安装激活"><a href="#安装激活" class="headerlink" title="安装激活"></a>安装激活</h2><ol><li><p>下载</p><p> 官网链接: <a href="https://www.charlesproxy.com/download/" rel="external nofollow noreferrer">https://www.charlesproxy.com/download/</a></p></li><li><p>激活</p></li></ol><pre><code class="tex">Registered Name ： https://zhile.ioLicense Key：48891cf209c6d32bf4</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具流</category>
      
      <category>Charles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Charles</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息系统项目管理</title>
    <link href="/alwaysblog/post/2949196864/"/>
    <url>/alwaysblog/post/2949196864/</url>
    
    <content type="html"><![CDATA[<blockquote><p>信息系统项目管理学习资料：</p><p>​    最好是 2020 年或 2021 年，首选是 51 CTO 薛大龙，然后是马军或野人老师等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软考 2022</category>
      
      <category>信息系统项目管理师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软考</tag>
      
      <tag>信息系统项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 常见问题总结</title>
    <link href="/alwaysblog/post/3467120238/"/>
    <url>/alwaysblog/post/3467120238/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-配置静态-IP"><a href="#linux-配置静态-IP" class="headerlink" title="linux 配置静态 IP"></a>linux 配置静态 IP</h2><ol><li>安装 ifconfig</li></ol><pre><code class="shell">    yum search ifconfig  =&gt; ifconfig 在 net-tools.x86_64 包中    sudo yum install net-tools.x86_64</code></pre><ol start="2"><li>查看 IP 信息<br>```shell<br> ifconfig / ip addr  # 查看IP 和子网掩码<pre><code> enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500     inet 192.168.1.222  netmask 255.255.255.0  broadcast 192.168.1.255     inet6 fe80::c597:178c:e00f:9029  prefixlen 64  scopeid 0x20&lt;link&gt;     ether 08:00:27:50:18:58  txqueuelen 1000  (Ethernet)     RX packets 4306  bytes 313127 (305.7 KiB)     RX errors 0  dropped 0  overruns 0  frame 0     TX packets 1243  bytes 225826 (220.5 KiB)     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre> route -n # 查看网关 GATEWAY<pre><code> [root@localhost etc]# route -n Kernel IP routing table Destination     Gateway         Genmask         Flags Metric Ref    Use Iface 0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 enp0s3 172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0 192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s3</code></pre></li></ol><pre><code>3. 修改配置文件```shell    vi /etc/sysconfig/network-scripts/ifcfg-enp0s3        TYPE=&quot;Ethernet&quot;    PROXY_METHOD=&quot;none&quot;    BROWSER_ONLY=&quot;no&quot;    DEFROUTE=&quot;yes&quot;    IPV4_FAILURE_FATAL=&quot;no&quot;    IPV6INIT=&quot;yes&quot;    IPV6_AUTOCONF=&quot;yes&quot;    IPV6_DEFROUTE=&quot;yes&quot;    IPV6_FAILURE_FATAL=&quot;no&quot;    IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;    NAME=&quot;enp0s3&quot;    UUID=&quot;65348731-3dab-47ae-a462-49eb2d7e7035&quot;    DEVICE=&quot;enp0s3&quot;    ONBOOT=&quot;yes&quot;    #####静态IP改动部分开始#####    # 动态 IP    # BOOTPROTO=&quot;dhcp&quot;    # 静态 IP    BOOTPROTO=&quot;static&quot;    IPADDR=192.168.1.222    NETMASK=255.255.255.0    GATEWAY=192.168.1.1    DNS1=114.114.114.114</code></pre><ol start="4"><li>添加 DNS 服务(首选DNS服务器和备选DNS服务器)</li></ol><pre><code class="shell">    vi /etc/resolv.conf    # Generated by NetworkManager    search localdomain    nameserver 114.114.114.114    nameserver 114.114.114.115                             </code></pre><ol start="5"><li>重启网络服务</li></ol><pre><code>    service network restart    systemctl network restart</code></pre><h2 id="Deepin-配置-SSH-远程"><a href="#Deepin-配置-SSH-远程" class="headerlink" title="Deepin 配置 SSH 远程"></a>Deepin 配置 SSH 远程</h2><ol><li>安装ssh服务</li></ol><pre><code class="SHELL">    sudo su    apt-get install openssh-server</code></pre><ol start="2"><li>修改配置文件</li></ol><pre><code class="shell">    vi /etc/ssh/sshd_config    # Authentication:    LoginGraceTime 2m    #PermitRootLogin prohibit-password    PermitRootLogin yes  # 允许 root 用户登录    StrictModes yes</code></pre><ol start="3"><li>重启SSH服务端</li></ol><pre><code class="shell">    sudo /etc/init.d/ssh start     或者     service ssh start</code></pre><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>问题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 环境搭建</title>
    <link href="/alwaysblog/post/2237793324/"/>
    <url>/alwaysblog/post/2237793324/</url>
    
    <content type="html"><![CDATA[<h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><h3 id="linux-安装-java"><a href="#linux-安装-java" class="headerlink" title="linux 安装 java"></a>linux 安装 java</h3><ul><li>查看系统是否安装过 java</li></ul><pre><code>yum search java | grep jdk</code></pre><ul><li>如果有旧版本的 java，可以用如下方法卸载 java</li></ul><pre><code>yum ‐y remove java‐1.8.0‐openjdk*</code></pre><ul><li>查看 java 软件包列表</li></ul><pre><code>yum ‐y list java*</code></pre><ul><li>下载安装 java1.8 的所有软件包，中途需要输入 y 来确认下载</li></ul><pre><code>yum install java‐1.8.0‐openjdk*</code></pre><ul><li>安装成功，输入如下命令检查是否安装成功，如果返回正确的版本号则表示安装成功。</li></ul><pre><code>java ‐version</code></pre><ul><li>java 安装目录</li></ul><pre><code>/usr/lib/jvm/java‐1.8.0‐openjdk</code></pre><h3 id="linux-安装-MySQL"><a href="#linux-安装-MySQL" class="headerlink" title="linux 安装 MySQL"></a>linux 安装 MySQL</h3><ul><li>使用 wget 获取 rpm 包</li></ul><pre><code>wget http://repo.mysql.com//mysql57‐community‐release‐el7‐8.noarch.rpm</code></pre><ul><li>安装 mysql community‐release</li></ul><pre><code>- yum ‐y install mysql57‐community‐release‐el7‐8.noarch.rpm</code></pre><ul><li>安装 mysql 服务器</li></ul><pre><code>yum ‐y install mysql‐community‐server.x86_64</code></pre><ul><li>启动 MySQL 服务器</li></ul><pre><code>systemctl start mysqld.service</code></pre><ul><li>检查 MySQL 服务器的状态</li></ul><pre><code>systemctl status mysqld.service</code></pre><ul><li>查看初始化密码</li></ul><pre><code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></pre><ul><li>使用初始化密码进入数据库</li></ul><pre><code>mysql ‐uroot ‐p</code></pre><ul><li>修改密码</li></ul><pre><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;简单密码&#39;;</code></pre><ul><li>修改密码强度</li></ul><pre><code>set global validate_password_length=4;set global validate_password_policy=0;</code></pre><ul><li>创建一个可以远程的账号</li></ul><pre><code>CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39;;</code></pre><ul><li>给远程的账号赋予权限</li></ul><pre><code>GRANT ALL ON _._ TO &#39;root&#39;@&#39;%&#39;;</code></pre><ul><li>如果还连不上，请关闭防火墙</li></ul><pre><code>查看防火墙状态： systemctl status firewalld.service执行关闭命令： systemctl stop firewalld.service再次执行查看防火墙命令：systemctl status firewalld.service执行开机禁用防火墙自启命令  ： systemctl disable firewalld.service启动：systemctl start firewalld.service防火墙随系统开启启动  ： systemctl enable firewalld.service</code></pre><ul><li>MySQL 8.0 连不上</li></ul><pre><code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;</code></pre><ul><li>详细参考: <a href="https://www.cnblogs.com/zhanyd/p/10001138.html" rel="external nofollow noreferrer">https://www.cnblogs.com/zhanyd/p/10001138.html</a></li></ul><h3 id="linux-安装-redis"><a href="#linux-安装-redis" class="headerlink" title="linux 安装 redis"></a>linux 安装 redis</h3><ul><li>详细参考: <a href="https://www.cnblogs.com/zuidongfeng/p/8032505.html" rel="external nofollow noreferrer">https://www.cnblogs.com/zuidongfeng/p/8032505.html</a></li><li>启动 redis: (启动目录：/root/redis-4.0.6/src)<ul><li>./redis-server /root/redis-4.0.6/redis.conf()</li></ul></li><li>查看进程： ps -ef | grep redis</li></ul><h3 id="linux-启动-jar-包"><a href="#linux-启动-jar-包" class="headerlink" title="linux 启动 jar 包"></a>linux 启动 jar 包</h3><ul><li>创建目录：/home/webapps/testsell (目录可以随便)</li><li>下载 rz<ul><li>yum install lrzsz</li><li>rz 上传文件</li><li>sz 下载文件</li></ul></li><li>启动 jar 包<ul><li>java -jar sell.jar</li><li>后台启动：nohup java -jar sell.jar</li><li>指定端口号启动:nohup java -jar sell.jar –server.port=8080</li></ul></li></ul><h2 id="Jenkins-自动化部署环境"><a href="#Jenkins-自动化部署环境" class="headerlink" title="Jenkins 自动化部署环境"></a>Jenkins 自动化部署环境</h2><ul><li>详细参考：<a href="https://note.youdao.com/ynoteshare1/index.html?id=01a3f11b1fd24459fbba82a0509f5d4e&amp;type=note" rel="external nofollow noreferrer">https://note.youdao.com/ynoteshare1/index.html?id=01a3f11b1fd24459fbba82a0509f5d4e&amp;type=note</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS 常见问题总结</title>
    <link href="/alwaysblog/post/1992094617/"/>
    <url>/alwaysblog/post/1992094617/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MacOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS 问题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win 常见问题总结</title>
    <link href="/alwaysblog/post/624053898/"/>
    <url>/alwaysblog/post/624053898/</url>
    
    <content type="html"><![CDATA[<h2 id="DOS-命令"><a href="#DOS-命令" class="headerlink" title="DOS 命令"></a>DOS 命令</h2><ol><li><p>修改文件大小（将其他文件的大小合并到需要扩充的文件）</p><pre><code class="shell">$ copy img.jpg /b + music.mp3 10Mimg.jpg# copy 原图名称 /b + 需要扩充的文件名称 新图名称</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows 问题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 零基础</title>
    <link href="/alwaysblog/post/3308975195/"/>
    <url>/alwaysblog/post/3308975195/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-的语言特点"><a href="#Python-的语言特点" class="headerlink" title="Python 的语言特点"></a>Python 的语言特点</h2>]]></content>
    
    
    <categories>
      
      <category>后端领域</category>
      
      <category>编程语言</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python 零基础</tag>
      
      <tag>极客时间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell 编程</title>
    <link href="/alwaysblog/post/4046588353/"/>
    <url>/alwaysblog/post/4046588353/</url>
    
    <content type="html"><![CDATA[<h2 id="shell-实例"><a href="#shell-实例" class="headerlink" title="shell 实例"></a>shell 实例</h2><ul><li>echo 用于向窗口输出文本<br>```shell<br>#!/bin/bash</li></ul><p>echo “时光静好，岁月安然！”</p><pre><code>- 脚本运行```shell$ ./test.sh$  sh test.sh</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>[ <strong>变量名的命名规则</strong> ]</p><ol><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li><li>中间不能有空格，可以使用下划线（_）</li><li>不能使用标点符号</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）</li></ol><ul><li><strong>变量赋值</strong><br>```shell<br>#!/bin/bash</li></ul><p>string=”从前冬天冷呀 夏天雨呀水呀 秋天远处传来你声音暖呀暖呀”</p><h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h1><p>echo ${string}</p><h1 id="语句给变量赋值-将-etc-下目录的文件名循环出来。将文件名-赋值给-file"><a href="#语句给变量赋值-将-etc-下目录的文件名循环出来。将文件名-赋值给-file" class="headerlink" title="语句给变量赋值 (将 /etc 下目录的文件名循环出来。将文件名 赋值给 file)"></a>语句给变量赋值 (将 /etc 下目录的文件名循环出来。将文件名 赋值给 file)</h1><p>for file in <code>ls /etc</code> 或 for file in $(ls /etc)<br>    do<br>    echo “文件： ${file}”<br>    done</p><pre><code>- **只读变量( readonly  )**```shell#!/bin/bash# 只读变量( readonly  )base_url=&quot;www.baidu.com&quot;readonly base_urlbase_url=&quot;www.google.com&quot;# 运行脚本，结果如下：    /bin/bash: NAME: This variable is read only.</code></pre><ul><li><strong>删除变量（unset ）</strong><br>```shell<br>#!/bin/bash</li></ul><p>variable_name=”System”<br>unset variable_name</p><p>echo ${variable_name}  # 没有任何输出</p><pre><code>- **变量类型**```shell1) 局部变量: 局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。2) 环境变量: 所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量。3) shell 变量: shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串可以用单引号，也可以用双引号，也可以不用引号<br>```shell<br>#!/bin/bash</li></ul><h1 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h1><p>str=’this is a string’<br>单引号字符串的限制：<br>    单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；<br>    单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p><h1 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h1><p>_name=’system’<br>str=”Hello, I know you are &quot;${_name}&quot;! \n”<br>echo -e ${str}</p><h1 id="输出结果为："><a href="#输出结果为：" class="headerlink" title="输出结果为："></a>输出结果为：</h1><pre><code>Hello, I know you are &quot;runoob&quot;! </code></pre><p>双引号的优点：<br>    双引号里可以有变量<br>    双引号里可以出现转义字符</p><pre><code>- **字符串拼接**```shell#!/bin/bash_name=&quot;system&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$_name&quot; !&quot;      # 双引号拼接greeting_1=&quot;hello, $&#123;_name&#125; !&quot;    # 双引号存在变量echo $greeting  $greeting_1# 使用单引号拼接greeting_2=&#39;hello, &#39;$_name&#39; !&#39;  # 单引号拼接greeting_3=&#39;hello, $&#123;_name&#125; !&#39;  # 单引号字符串中存在变量echo $greeting_2  $greeting_3# 输出结果hello, system ! hello, system !hello, system ! hello, $&#123;_name&#125; !   # 单引号字符串中存在变量，原样输出</code></pre><ul><li><strong>获取字符串长度</strong><pre><code class="shell">#!/bin/shstring=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4</code></pre></li></ul><ul><li><strong>提取字符串</strong><br>```shell<br>#!/bin/sh<br>string=”从前冬天冷呀 夏天雨呀水呀 秋天远处传来你声音暖呀暖呀”</li></ul><p>echo ${string:0:6}  # 输出 从前冬天冷呀(包含 0, 但不包含 6)  第一个字符的索引值为 0</p><p>注意： </p><ol><li>不支持负数切片</li><li>如果后一个数小于开始的数字，则该值表示向后延伸长度（如：${string:7:3} &gt;&gt; 夏天雨）</li><li>如果后一个数大于开始的数字，则该值表示向后延伸位置（如：${string:3:7} &gt;&gt; 天冷呀 夏天雨）<br>```</li></ol><ul><li><strong>查找字符串</strong><br>```shell<br>#!/bin/sh<br>string=”从前冬天冷呀 夏天雨呀水呀 秋天远处传来你声音暖呀暖呀”</li></ul><h1 id="查找字符-i-或-o-的位置-哪个字母先出现就计算哪个-："><a href="#查找字符-i-或-o-的位置-哪个字母先出现就计算哪个-：" class="headerlink" title="查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)："></a>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</h1><p>echo <code>expr index &quot;$string&quot; 呀秋</code> # 输出 6（从 1 开始 ）</p><pre><code>## shell 数组- **定义数组**    在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。定义数组的一般形式为```shell# 数组名=(值1 值2 ... 值n)array=(0 1 2 3 n)# 可以单独定义数组的各个分量：array_name[0]=value0array_name[1]=value1array_name[n]=valuen  # 可以不使用连续的下标，而且下标的范围没有限制</code></pre><ul><li><strong>读取数组</strong><br>```shell<br>#!/bin/bash<br>array=(0 1 2 3 “时光” “静好” (value0 value1 value2 value3) )</li></ul><p>echo ${array[0]}</p><h1 id="使用-或-符号可以获取数组中的所有元素"><a href="#使用-或-符号可以获取数组中的所有元素" class="headerlink" title="使用 @ 或 * 符号可以获取数组中的所有元素"></a>使用 @ 或 * 符号可以获取数组中的所有元素</h1><p>echo ${array[@]} # 输出： 0 1 2 3 时光 静好</p><pre><code>- **获取数组的长度**```shell#!/bin/basharray=(0 1 2 3 &quot;时光&quot; &quot;静好&quot; )# 取得数组元素的个数 length=$&#123;#array[@]&#125;# 或者length=$&#123;#array[*]&#125;echo $&#123;length&#125; # 6# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125;lengthn=$&#123;#array_name[4]&#125;echo $&#123;lengthn&#125; # 2</code></pre><h2 id="shell-注释"><a href="#shell-注释" class="headerlink" title="shell 注释"></a>shell 注释</h2><ul><li>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略<br>```shell<br>#!/bin/bash</li></ul><p>#——————————————–</p><h1 id="这是一个注释"><a href="#这是一个注释" class="headerlink" title="这是一个注释"></a>这是一个注释</h1><h1 id="author："><a href="#author：" class="headerlink" title="author："></a>author：</h1><h1 id="site："><a href="#site：" class="headerlink" title="site："></a>site：</h1><h1 id="slogan："><a href="#slogan：" class="headerlink" title="slogan："></a>slogan：</h1><p>#——————————————–</p><h5 id="用户配置区-开始"><a href="#用户配置区-开始" class="headerlink" title="用户配置区 开始"></a>用户配置区 开始</h5><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="这里可以添加脚本描述信息"><a href="#这里可以添加脚本描述信息" class="headerlink" title="这里可以添加脚本描述信息"></a>这里可以添加脚本描述信息</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h5 id="用户配置区-结束"><a href="#用户配置区-结束" class="headerlink" title="用户配置区 结束"></a>用户配置区 结束</h5><pre><code>- **多行注释**```shell#!/bin/bash:&lt;&lt;EOF注释内容...注释内容...注释内容... EOF# EOF 也可以使用其他符号::&lt;&lt;&#39;注释内容...注释内容...注释内容...&#39;:&lt;&lt;!注释内容...注释内容...注释内容...!</code></pre><h2 id="shell-传递参数"><a href="#shell-传递参数" class="headerlink" title="shell 传递参数"></a>shell 传递参数</h2><blockquote><p>在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n<strong>。</strong>n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p></blockquote><ul><li>实例<br>```shell<br>#!/bin/bash<h1 id="file-name-test-sh"><a href="#file-name-test-sh" class="headerlink" title="file_name = test.sh"></a>file_name = test.sh</h1><h1 id="以下实例我们向脚本传递三个参数，并分别输出，其中-0-为执行的文件名（包含文件路径）"><a href="#以下实例我们向脚本传递三个参数，并分别输出，其中-0-为执行的文件名（包含文件路径）" class="headerlink" title="以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名（包含文件路径）"></a>以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名（包含文件路径）</h1></li></ul><p>echo “Shell 传递参数实例！”;<br>echo “执行的文件名：$0”;<br>echo “第一个参数为：$1”;<br>echo “第二个参数为：$2”;<br>echo “第三个参数为：$3”;</p><h1 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h1><p>sh test.sh 1 2 3<br>    Shell 传递参数实例！<br>    执行的文件名：test.sh<br>    第一个参数为：1<br>    第二个参数为：2<br>    第三个参数为：3</p><p>./test.sh 3 2 1<br>    Shell 传递参数实例！<br>    执行的文件名：./test.sh<br>    第一个参数为：3<br>    第二个参数为：2<br>    第三个参数为：1</p><pre><code>| 参数处理 | 说明 || :--- | :--- || $# | 传递到脚本的参数个数 || $* | 以一个单字符串显示所有向脚本传递的参数。 如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。 || $$ | 脚本运行的当前进程 ID 号 || $! | 后台运行的最后一个进程的 ID号 || $@ | 与 $$* 相同，但是使用时加引号，并在引号中返回每个参数。 如&quot;$$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$$2&quot; … &quot;$$n&quot; 的形式输出所有参数。 || $- | 显示Shell使用的当前选项，与 [set命令](https://www.runoob.com/linux/linux-comm-set.html) 功能相同。 || $? | 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。 |- **$_ 与 $@ 区别_```tex相同点：都是引用所有参数。不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。</code></pre><h2 id="shell-运算符"><a href="#shell-运算符" class="headerlink" title="shell 运算符"></a>shell 运算符</h2><blockquote><p>shell 运算符包括 算术运算符、关系运算符、布尔运算符、字符串运算符、文件测试运算符<br>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。<br>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p></blockquote><ul><li>实例<br>```shell<br>#!/bin/bash</li></ul><p>val=<code>expr 5 + 5</code></p><h1 id="等价于"><a href="#等价于" class="headerlink" title="等价于"></a>等价于</h1><p>val=$[a+b]</p><p>echo ${val} # 10</p><pre><code>   - 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。   - 完整的表达式要被 ”``“ 包含- **算术运算符**```shell#!/bin/bash#  + 、- 、* 、 / 、= 、% 、 == 、 ！=      # 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。a=50b=27result=`expr $a + $b`echo &quot;a + b : $&#123;result&#125;&quot;result=`expr $&#123;a&#125; - $&#123;b&#125;`echo &quot;a - b : $&#123;result&#125;&quot;# 乘号(*)前边必须加反斜杠(\)才能实现乘法运算# 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 &quot;*&quot; 不需要转义符号 &quot;\&quot; result=`expr $a \* $b`echo &quot;a * b : $&#123;result&#125;&quot;result=`expr $a / $b`echo &quot;a / b : $&#123;result&#125;&quot;result=`expr $a % $b`echo &quot;a % b : $&#123;result&#125;&quot;# 注意空格 [ $a == $b ] if [ $a == $b ] then   echo &quot; a 等于 b&quot;fiif [ $a != $b ] then  echo &quot;a 不等于 b&quot;fi</code></pre><ul><li><strong>关系运算符</strong><blockquote><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p></blockquote></li></ul><table><thead><tr><th align="left">运算符</th><th align="left">说明（假定变量 a 为 10，变量 b 为 20）</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-eq</td><td align="left">检测两个数是否相等，相等返回 true。</td><td align="left">[ $a -eq $b ] 返回 false。</td></tr><tr><td align="left">-ne</td><td align="left">检测两个数是否不相等，不相等返回 true。</td><td align="left">[ $a -ne $b ] 返回 true。</td></tr><tr><td align="left">-gt</td><td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td><td align="left">[ $a -gt $b ] 返回 false。</td></tr><tr><td align="left">-lt</td><td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td><td align="left">[ $a -lt $b ] 返回 true。</td></tr><tr><td align="left">-ge</td><td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td align="left">[ $a -ge $b ] 返回 false。</td></tr><tr><td align="left">-le</td><td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td align="left">[ $a -le $b ] 返回 true。</td></tr></tbody></table><pre><code class="shell">#!/bin/basha=50b=20# -eqif [ $a -eq $b ]then   echo &quot;-eq : a 等于 b&quot;else   echo &quot;-eq : a 不等于 b&quot;fi</code></pre><ul><li><strong>布尔运算符</strong><table><thead><tr><th align="left">运算符</th><th align="left">说明（假定变量 a 为 10，变量 b 为 20）</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">!</td><td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td align="left">[ ! false ] 返回 true。</td></tr><tr><td align="left">-o</td><td align="left">或运算，有一个表达式为 true 则返回 true。</td><td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td align="left">-a</td><td align="left">与运算，两个表达式都为 true 才返回 true。</td><td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table></li></ul><pre><code class="shell">#!/bin/basha=50b=20if [ $a != $b ]then   echo &quot;a 不等于 b， 返回 true&quot;else   echo &quot; a 等于 b&quot;fiif [ $a -gt 100 -o $b -lt 50 ]then  echo &quot;a 大于 100或 b小于50 满足一个条件成立 &quot;fiif [ $a -gt 100 -a $b -lt 50 ]then  echo &quot;a 大于 100 与 b小于50 返回 false &quot;else   echo &quot;条件不成立， 必须同时满足， a 大于 100， b 小于 50&quot;</code></pre><ul><li><strong>逻辑运算符</strong><table><thead><tr><th align="left">运算符</th><th align="left">说明（假定变量 a 为 10，变量 b 为 20）</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑的 AND</td><td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td align="left">&#124;&#124;</td><td align="left">逻辑的 OR</td><td align="left">[[ $a -lt 100 &#124;&#124; $b -gt 100 ]] 返回 true</td></tr></tbody></table></li></ul><pre><code class="shell">#!/bin/basha=10b=20if [[ $a -gt 100 || $b -lt 50 ]]then  echo &quot;a 大于 100 或 b 小于 50 条件成立 返回 true&quot;else   echo &quot;a 大于 100 或 b 小于 50 条件不成立 返回 false&quot;fiif [[ $a -gt 100 &amp;&amp; $b -lt 50 ]]then  echo &quot;a 大于 100 与 b小于50 返回 true &quot;else   echo &quot;条件不成立, false， 必须同时满足， a 大于 100， b 小于 50&quot;fi</code></pre><ul><li><p><strong>字符串运算符</strong></p><table><thead><tr><th align="left">运算符</th><th align="left">说明（假定变量 a 为 “abc”，变量 b 为 “efg”）</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">检测两个字符串是否相等，相等返回 true。</td><td align="left">[ $a = $b ] 返回 false。</td></tr><tr><td align="left">!=</td><td align="left">检测两个字符串是否相等，不相等返回 true。</td><td align="left">[ $a != $b ] 返回 true。</td></tr><tr><td align="left">-z</td><td align="left">检测字符串长度是否为0，为0返回 true。</td><td align="left">[ -z $a ] 返回 false。</td></tr><tr><td align="left">-n</td><td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td><td align="left">[ -n “$a” ] 返回 true。</td></tr><tr><td align="left">$</td><td align="left">检测字符串是否为空，不为空返回 true。</td><td align="left">[ $a ] 返回 true。</td></tr></tbody></table></li><li><p><strong>文件测试运算符</strong></p><blockquote><p>文件测试运算符用于检测 Unix 文件的各种属性。</p></blockquote></li></ul><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="left">[ -b $file ] 返回 false。</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="left">[ -c $file ] 返回 false。</td></tr><tr><td align="left">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td><td align="left">[ -d $file ] 返回 false。</td></tr><tr><td align="left">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td align="left">[ -f $file ] 返回 true。</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="left">[ -g $file ] 返回 false。</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td align="left">[ -k $file ] 返回 false。</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td><td align="left">[ -p $file ] 返回 false。</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="left">[ -u $file ] 返回 false。</td></tr><tr><td align="left">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td><td align="left">[ -r $file ] 返回 true。</td></tr><tr><td align="left">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td><td align="left">[ -w $file ] 返回 true。</td></tr><tr><td align="left">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td><td align="left">[ -x $file ] 返回 true。</td></tr><tr><td align="left">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td align="left">[ -s $file ] 返回 true。</td></tr><tr><td align="left">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td align="left">[ -e $file ] 返回 true。</td></tr></tbody></table><ul><li>其他检查符：<ul><li><strong>-S</strong>: 判断某文件是否 socket。</li><li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。<br>```shell<br>#!/bin/bash</li></ul></li></ul><p>file=”/tmp/exlog/test.sh”</p><p>if [ -d $file ]<br>then<br>   echo “文件是个目录”<br>else<br>   echo “文件不是个目录”<br>fi<br>if [ -r $file ]<br>then<br>   echo “文件可读”<br>else<br>   echo “文件不可读”<br>fi<br>if [ -w $file ]<br>then<br>   echo “文件可写”<br>else<br>   echo “文件不可写”<br>fi<br>if [ -x $file ]<br>then<br>   echo “文件可执行”<br>else<br>   echo “文件不可执行”<br>fi</p><pre><code>## shell 输出#### echo命令```shell#!/bin/bashecho &quot;It is a test&quot; / echo It is a test### 显示转义字符echo &quot;\&quot;It is a test\&quot;&quot;### 显示变量# read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量printf &quot;请输入变量： &quot;read name echo &quot;$name It is a test&quot;# 保存为 main.sh 文件 执行[root@localhost exlog]# sh main.sh 请输入变量：qweqwe It is a test ### 显示换行echo -e &quot;OK! \n&quot; # -e 开启转义echo &quot;It is a test&quot;# 输出结果：OK!It is a test### 显示不换行echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行echo &quot;It is a test&quot;# 输出结果：OK! It is a test### 显示结果定向至文件printf &quot;请输入变量： &quot;read name echo &quot;$name It is a test&quot; &gt; test.sh# 保存为 main.sh 文件 执行, cat test.sh### 原样输出字符串，不进行转义或取变量(用单引号)echo &#39;$name\&quot;&#39;  # 输入结果  $name\&quot;### 显示命令执行结果 注意： 这里使用的是反引号 `, 而不是单引号 &#39;echo `date`# Thu Jul 24 10:08:46 CST 2014</code></pre><h4 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h4><blockquote><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。<br>默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n</p></blockquote><pre><code class="shell">#!/bin/bashecho &quot;Hello, Shell&quot;printf &quot;Hello, Shell\n&quot;printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876# 输出结果    姓名     性别   体重kg    郭靖     男      66.12    杨过     男      48.65    郭芙     女      47.99</code></pre><p><strong>%s %c %d %f</strong> 都是格式替代符，<strong>％s</strong> 输出一个字符串，<strong>％d</strong> 整型输出，<strong>％c</strong> 输出一个字符，<strong>％f</strong> 输出实数，以小数形式输出。<br><strong>%-10s</strong> 指一个宽度为 10 个字符（**-** 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><strong>%-4.2f</strong> 指格式化为小数，其中 <strong>.2</strong> 指保留2位小数。</p><h2 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">command &gt; file</td><td align="left">将输出重定向到 file。</td></tr><tr><td align="left">command &lt; file</td><td align="left">将输入重定向到 file。</td></tr><tr><td align="left">command &gt;&gt; file</td><td align="left">将输出以追加的方式重定向到 file。</td></tr><tr><td align="left">n &gt; file</td><td align="left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td align="left">n &gt;&gt; file</td><td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td align="left">n &gt;&amp; m</td><td align="left">将输出文件 m 和 n 合并。</td></tr><tr><td align="left">n &lt;&amp; m</td><td align="left">将输入文件 m 和 n 合并。</td></tr><tr><td align="left">&lt;&lt; tag</td><td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><blockquote><p><em>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</em></p></blockquote><h2 id="shell-流程控制"><a href="#shell-流程控制" class="headerlink" title="shell 流程控制"></a>shell 流程控制</h2><h3 id="if-控制语句"><a href="#if-控制语句" class="headerlink" title="if 控制语句"></a>if 控制语句</h3><pre><code class="shell">#!/bin/basha=10b=20if [ $a == $b ]then   echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then   echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi</code></pre><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre><code class="shell">#!/bin/bashfor loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done# 序输出字符串中的字符for str in This is a stringdo    echo $strdone# 输出结果    This    is    a    string# 通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要for((i=1;i&lt;=5;i++));do    echo &quot;这是第 $i 次调用&quot;;done;</code></pre><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><pre><code class="shell">#!/bin/bash#!/bin/bashint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done</code></pre><blockquote><p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</p></blockquote><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code class="shell">#!/bin/bashwhile truedo  printf &quot;请输入内容：&quot;  read content  echo &quot;您输入额内容是 $&#123;content&#125;&quot;done# 或者while ：do  printf &quot;请输入内容：&quot;  read content  echo &quot;您输入额内容是 $&#123;content&#125;&quot;done#或者for (( ; ; ))do  printf &quot;请输入内容：&quot;  read content  echo &quot;您输入额内容是 $&#123;content&#125;&quot;done</code></pre><h3 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h3><blockquote><p>until 循环执行一系列命令直至条件为 true 时停止。<br>until 循环与 while 循环在处理方式上刚好相反。<br>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p></blockquote><pre><code class="shell">#!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done</code></pre><h3 id="case-…-esac"><a href="#case-…-esac" class="headerlink" title="case … esac"></a>case … esac</h3><blockquote><p><strong>case … esac</strong> 为多选择语句,是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。<br>可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。</p></blockquote><pre><code class="shell">echo &#39;输入 1 到 4 之间的数字:&#39;echo &#39;你输入的数字为:&#39;read aNumcase $aNum in    1)  echo &#39;你选择了 1&#39;    ;;    2)  echo &#39;你选择了 2&#39;    ;;    3)  echo &#39;你选择了 3&#39;    ;;    4)  echo &#39;你选择了 4&#39;    ;;    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;    ;;esac</code></pre><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><ul><li><strong>break</strong><blockquote><p>break 命令允许跳出所有循环（终止执行后面的所有循环）</p></blockquote></li></ul><pre><code class="shell">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone</code></pre><ul><li><strong>continue</strong><blockquote><p>continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p></blockquote></li></ul><pre><code class="shell">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字: &quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><h2 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h2><pre><code class="shell">#!/bin/bash# shell 函数定义[ function ] funname [()]&#123;    action;    [return int;]&#125;</code></pre><blockquote><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</li></ul></blockquote><ul><li><strong>实例</strong><br>```shell<br>#!/bin/bash</li></ul><p>function demo (){<br>  echo “这是一个 shell 函数！”<br>}</p><p>echo “—– 函数开始执行 —–”</p><p>demo()</p><p>echo “—– 函数执行完毕 —–”</p><h1 id="函数-return"><a href="#函数-return" class="headerlink" title="函数 return"></a>函数 return</h1><p>function demo_return(){<br>  a=10<br>  b=20<br>  return $((a + b))</p><h1 id="return-a-b"><a href="#return-a-b" class="headerlink" title="return $(($a + $b))"></a>return $(($a + $b))</h1><h1 id="return-a-b-1"><a href="#return-a-b-1" class="headerlink" title="return $[a + b]"></a>return $[a + b]</h1><p>}</p><p>demo_return<br>echo “和：$?”</p><pre><code>&gt; 函数返回值在调用该函数后通过 $? 来获得。&gt; 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可- **函数参数**&gt; 在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...&gt; 注意，$$10 不能获取第十个参数，获取第十个参数需要$$&#123;10&#125;。当n&gt;=10时，需要使用$&#123;n&#125;来获取参数。| 参数处理 | 说明 || :--- | :--- || $# | 传递到脚本或函数的参数个数 || $* | 以一个单字符串显示所有向脚本传递的参数 || $$ | 脚本运行的当前进程ID号 || $! | 后台运行的最后一个进程的ID号 || $@ | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 || $- | 显示Shell使用的当前选项，与set命令功能相同。 || $? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |```shell#!/bin/bashfunWithParam()&#123;    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 $&#123;10&#125; !&quot;    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;    echo &quot;脚本运行的当前进程ID号: $$&quot;    echo &quot;后台运行的最后一个进程的ID号:$!&quot;    echo &quot;$-&quot;    echo &quot;$?&quot;    &#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><ul><li><strong>注意点</strong></li></ul><pre><code class="shell">#!/bin/bashfunction demoFun1()&#123;    echo &quot;这是我的第一个 shell 函数!&quot;    return `expr 1 + 1`&#125;demoFun1echo $?function demoFun2()&#123; echo &quot;这是我的第二个 shell 函数!&quot; expr 1 + 1&#125;demoFun2echo $?demoFun1echo 在这里插入命令！echo $?  # 显示 上一条 echo 在这里插入命令！ 的结果，0表示没有错误，其他任何值表明有错误。# 输出结果这是我的第一个 shell 函数!2这是我的第二个 shell 函数!20这是我的第一个 shell 函数!在这里插入命令！0</code></pre><blockquote><p>调用 demoFun2 后，函数最后一条命令 expr 1 + 1 得到的返回值（$?值）为 0，意思是这个命令没有出错。所有的命令的返回值仅表示其是否出错，而不会有其他有含义的结果。<br>第二次调用 demoFun1 后，没有立即查看 $? 的值，而是先插入了一条别的 echo 命令，最后再查看 $? 的值得到的是 0，也就是上一条 echo 命令的结果，而 demoFun1 的返回值被覆盖了。<br>下面这个测试，连续使用两次 **echo $?**，得到的结果不同，更为直观：</p></blockquote><pre><code class="shell">#!/bin/bashfunction demoFun1()&#123;    echo &quot;这是我的第一个 shell 函数!&quot;    return `expr 1 + 1`&#125;demoFun1echo $?echo $?   # 显示 上一条 echo $? 的结果，0表示没有错误，其他任何值表明有错误。# 输出结果这是我的第一个 shell 函数!20</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端领域</category>
      
      <category>编程语言</category>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 基础</title>
    <link href="/alwaysblog/post/2562162005/"/>
    <url>/alwaysblog/post/2562162005/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-环境搭建"><a href="#Python-环境搭建" class="headerlink" title="Python 环境搭建"></a>Python 环境搭建</h2><ul><li>下载安装</li></ul><pre><code class="shell">$ 下载页面：https://www.python.org/downloads/windows/    2.7：https://www.python.org/downloads/release/python-2718/（选择：Windows x86-64 MSI installer）    3.8：https://www.python.org/downloads/release/python-385/（选择：Windows x86-64 executable installer）    2.7 版本直连：https://www.python.org/ftp/python/2.7.18/python-2.7.18.amd64.msi    3.7 版本直连：https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe</code></pre><ul><li>pip 升级</li></ul><pre><code class="shell">$ python2 -m pip install --upgrade pip --force-reinstall$ python3 -m pip install --upgrade pip --force-reinstall</code></pre><ul><li>虚拟环境</li></ul><pre><code class="shell">在 python3 的环境下创建$ 安装虚拟环境软件包：pip3 install virtualenv$ 创建虚拟环境： virtualenv Venv$ 虚拟环境管理器安装： pip3 install virtualenvwrapper-win$ 添加全局变量配置虚拟环境路径： WORKON_HOME  / C:\Python\Virtualenv    =&gt; 虚拟环境都创建在此目录下    创建虚拟环境： mkvirtualenv Venv(虚拟环境名称)    激活虚拟环境： workon Venv(虚拟环境名称)    退出虚拟环境： deactivate    删除虚拟环境： rmvirtualenv Venv(虚拟环境名称)    列出虚拟环境： workon / lsvirtualenv    创建虚拟环境指定 Python 版本： mkvirtualenv --python==C:\Python\Python37\python.exe 虚拟环境名称</code></pre><ul><li>第三方包本地安装</li></ul><pre><code class="shell">$  **.whl : $        pip install  **.whl$  **.egg : $        1. 先下载ez_setup.py,运行python ez_setup 进行easy_install工具的安装$        2. easy_install **.egg$  **.zip / tar.gz        python setup.py install</code></pre><h2 id="Python-数据类型"><a href="#Python-数据类型" class="headerlink" title="Python 数据类型"></a>Python 数据类型</h2><p><strong>不可变数据类型：</strong> Number（数字）、String（字符串）、Tuple（元组）</p><p><strong>可变数据类型：</strong>   List（列表）、Dictionary（字典）、Set（集合）</p><p><strong>序列容器：</strong> String（字符串）、List（列表）Tuple（元组）</p><p><strong>非序列容器</strong>：Dictionary（字典）、Set（集合）</p><h3 id="数据类型之间的运算规则"><a href="#数据类型之间的运算规则" class="headerlink" title="数据类型之间的运算规则"></a>数据类型之间的运算规则</h3><ul><li>算术运算符</li></ul><pre><code>常见运算符：+ 、 - 、 * 、/ （/ 在 python2 和 python3 中的作用不同）** : 幂运算 2 ** 3 &lt;==&gt; 2 的三次方// : 取整运算%  ：取余运算/ 在python 2.X 当除数与被除数都是整数时，取整数，当其中一个为浮点数时，结果为浮点数，在 3.x 则直接为浮点数</code></pre><ul><li>赋值运算符</li></ul><pre><code>常见运算符：= 、+= 、-= 、*=、/= (A += B 相当于 A = A + B)//=    : A //= B &lt;==&gt; A = A // B%=    : A %= B &lt;==&gt; A = A % B**= : A **= B &lt;==&gt; A = A ** B</code></pre><ul><li>比较运算符</li></ul><pre><code>常见运算符：&gt;, &lt; , &gt;=, &lt;=, ==, != Python 中 没有 全等于 ===</code></pre><ul><li>逻辑运算符</li></ul><pre><code class="python"># 逻辑运算符:逻辑与 and， 逻辑或 or， 逻辑非not (and，全真则真； or，全假为假)# and(且)  ==&gt; 非 0 为真， 0 为假ret = 0 and 2 # ==&gt; 第一个条件为假，没有必要检查第二个条件 故 输出第一个条件 0ret = 1 and 0 # ==&gt; 第一个条件为真，第二个条件必须执行   输出第二个条件 0ret = 1 and 2 # ==&gt; 第一个条件为真，第二个条件必须执行   输出第二个条件 2# or(或)   ==&gt; 一个为真则为真ret = 1 or 2  # 检查第一个条件，为真， 输出第一个条件 0ret = 0 or 1  # 第一个条件为假，第二个条件必须执行   输出第二个条件 1ret = 0 or 0  # 第一个条件为假，第二个条件必须执行   输出第二个条件 0</code></pre><ul><li><strong>数据类型之间运算规则</strong></li></ul><pre><code>总结：  1. 数字和数字之间可以进行所有的运算  2. 字符串和字符串之间只能进行加法运算  3. 数字和字符串之间只能进行乘法运算</code></pre><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p><strong>前提：可以转换为目标类型</strong></p><ul><li>转换为 Number 类型</li></ul><pre><code class="python">value = &#39;666&#39;int(value) # ==&gt; 666</code></pre><ul><li>转换为 String 类型</li></ul><pre><code class="python">value = 666str(value)  ==&gt; &#39;666&#39;</code></pre><ul><li>转换为 float 类型</li></ul><pre><code class="python">value = 666 # ‘666’呢？float(value)  ==&gt; 666.00</code></pre><h3 id="数字（Number）"><a href="#数字（Number）" class="headerlink" title="数字（Number）"></a>数字（Number）</h3><ul><li>整数（integer）</li><li>小数 / 浮点数（float）</li></ul><p><strong>[ 常用的数字函数 ]</strong></p><pre><code class="python">abs(x)          #返回数字的绝对值，如abs(-10) 返回 10math.fabs(x)    #返回数字的绝对值，如math.fabs(-10) 返回10.0exp(x)          #返回e的x次幂(e^x),如math.exp(1) 返回2.718281828459045math.log(x)     #返回x的对数如math.log(math.e)返回1.0,math.log(100,10)返回2.0math.log10(x)   #返回以10为基数的x的对数，如math.log10(100)返回 2.0math.modf(x)    #返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示pow(x)          #返回x**y 运算后的值math.sqrt(x)    #返回数字x的平方根round(x,[n])    #返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数math.sin(x)     #返回的x弧度的正弦值</code></pre><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><ul><li>字符串是 Python 中最常用的数据类型。我们可以使用引号( ’ 或 “ )来创建字符串</li><li>字符串切片索引</li></ul><pre><code class="python">str = &#39;Runoob&#39;print (str)          # 输出字符串print (str[0:-1])    # 输出第一个到倒数第二个的所有字符print (str[0])       # 输出字符串第一个字符print (str[2:5])     # 输出从第三个开始到第五个的字符print (str[2:])      # 输出从第三个开始的后的所有字符print (str * 2)      # 输出字符串两次print (str + &quot;TEST&quot;) # 连接字符串# 输出RunoobRunooRnoonoobRunoobRunoobRunoobTEST</code></pre><p><strong>[ python三引号 ]</strong></p><p>python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符</p><pre><code class="python">para_str = &quot;&quot;&quot;这是一个多行字符串的实例    多行字符串可以使用制表符    TAB ( \t )。    也可以使用换行符 [ \n ]。    &quot;&quot;&quot;print (para_str)# 输出这是一个多行字符串的实例多行字符串可以使用制表符TAB (    )。也可以使用换行符 [ ]。</code></pre><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><ul><li>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现，列表的数据项不需要具有相同的类型</li><li>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可</li><li>列表切片索引</li></ul><p><strong>[ 常用的列表函数 ]</strong></p><pre><code class="python">list.append(obj)          #在列表末尾添加新的对象list.count(obj)           #统计某个元素在列表中出现的次数list.extend(seq)          #在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）list.index(obj)           #从列表中找出某个值第一个匹配项的索引位置list.pop([index=-1])      #移除列表中的一个元素（默认最后一个元素），并且返回该元素的值list.remove(obj)          #移除列表中某个值的第一个匹配项list.reverse()            #反向列表中元素list.sort( key=None, reverse=False)    #对原列表进行排序,True 降序,False 升序（默认）list.clear()              #清空列表list.copy()               #复制列表</code></pre><h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><ul><li>元组与列表类似，不同之处在于元组的元素不能修改</li></ul><h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><ul><li>字典是另一种可变容器模型，且可存储任意类型对象</li><li><strong>dict = {key1 : value1, key2 : value2 }：</strong>每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中</li><li><strong>注意：</strong>键必须是唯一的，但值则不必；值可以取任何数据类型（如字符串，数字或元组），但键必须是不可变的。</li></ul><p><strong>[ 访问字典的值 ]</strong></p><pre><code class="python">dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;&#39;&#39;&#39;    del dict[&#39;Name&#39;]     # 删除键 &#39;Name&#39;    dict.clear()         # 清空字典    del dict             # 删除字典    &#39;&#39;&#39;print (&quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;])print (&quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;])# 输出dict[&#39;Name&#39;]:  Runoob    dict[&#39;Age&#39;]:  7</code></pre><p><strong>[ 字典键的特性 ]</strong></p><ul><li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</li></ul><pre><code class="python">dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Name&#39;: &#39;小菜鸟&#39;&#125;print (&quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;])123#输出dict[&#39;Name&#39;]:  小菜鸟    12</code></pre><ul><li>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</li></ul><pre><code class="python">dict = &#123;[&#39;Name&#39;]: &#39;Runoob&#39;, &#39;Age&#39;: 7&#125;print (&quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;])123#输出Traceback (most recent call last):    File &quot;test.py&quot;, line 3, in &lt;module&gt;    dict = &#123;[&#39;Name&#39;]: &#39;Runoob&#39;, &#39;Age&#39;: 7&#125;    TypeError: unhashable type: &#39;list&#39;</code></pre><p><strong>[ 字典函数 ]</strong></p><pre><code class="python">radiansdict.clear()          #删除字典内所有元素pop(key[,default])           #删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值</code></pre><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><ul><li>集合是一个无序的不重复元素序列，可以使用大括号 { } 或者 set() 函数创建集合</li><li><strong>注意：</strong>创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典</li></ul><pre><code class="python">basket = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;print(basket)                      # 去重功能#输出&#123;&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;&#125;&#39;orange&#39; in basket                 # 快速判断元素是否在集合内#输出True&#39;crabgrass&#39; in basket#输出False# 下面展示两个集合间的运算a = set(&#39;abracadabra&#39;)b = set(&#39;alacazam&#39;)print(a)#输出                                  &#123;&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;print(a - b)                              # 集合a中包含而集合b中不包含的元素#输出&#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;print(a | b)                              # 集合a或b中包含的所有元素#输出&#123;&#39;c&#39;, &#39;b&#39;, &#39;r&#39;, &#39;z&#39;, &#39;l&#39;, &#39;m&#39;, &#39;a&#39;, &#39;d&#39;&#125;print(a &amp; b)                              # 集合a和b中都包含了的元素#输出&#123;&#39;a&#39;, &#39;c&#39;&#125;print(a ^ b)                              # 不同时包含于a和b的元素#输出&#123;&#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;r&#39;, &#39;m&#39;, &#39;d&#39;&#125;</code></pre><p><strong>[ 添加元素 ]</strong></p><ul><li><strong>s.add( x )</strong> 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作</li></ul><pre><code class="python">thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))thisset.add(&quot;Facebook&quot;)print(thisset)#输出&#123;&#39;Taobao&#39;, &#39;Facebook&#39;, &#39;Google&#39;, &#39;Runoob&#39;&#125;</code></pre><ul><li><strong>s.update( x )</strong> 参数可以是列表，元组，字典等</li></ul><pre><code class="python">thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))thisset.update(&#123;1,3&#125;)print(thisset)#输出&#123;1, 3, &#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;&#125;thisset.update([1,4],[5,6])  print(thisset)#输出&#123;1, 3, 4, 5, 6, &#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;&#125;</code></pre><p><strong>[ 移除元素 ]</strong></p><pre><code class="python">s.remove( x )        # 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误s.discard( x )        # 移除集合中的元素，如果元素不存在，不会发生错误s.pop()                # 随机删除集合中的一个元素，在交互模式，pop 是删除集合的第一个元素（排序后的集合的第一个元素）</code></pre><p><strong>[ 集合函数 ]</strong></p><pre><code class="python">add()            #为集合添加元素clear()            #移除集合中的所有元素copy()            #拷贝一个集合union()            #返回两个集合的并集update()        #给集合添加元素</code></pre><h2 id="Python-输入输出"><a href="#Python-输入输出" class="headerlink" title="Python 输入输出"></a>Python 输入输出</h2><h3 id="标准输入输出函数"><a href="#标准输入输出函数" class="headerlink" title="标准输入输出函数"></a>标准输入输出函数</h3><ul><li><strong>print()</strong> 标准输出函数</li></ul><pre><code class="python">#  换行符  \n,  end=&#39;\n&#39;print(&#39;aaa&#39; end=&#39;&#39;) # 不换行print(&#39;bbb&#39; end=&#39;#&#39;) # bbb 和 ccc 之间用 # 连接print(&#39;ccc&#39;)# 格式化输出name = &#39;鲁班&#39;age = 20&gt; %s ==&gt; string&gt; %d ==&gt; digit(数字)&gt; %f ==&gt; float&gt; %% ==&gt; 输出 %print(&#39;他的名字是&#39; + name +&#39;,他的年龄是&#39; + age + &#39;。&#39;) # 输出格式print(&#39;他的名字是%s,他的年龄是%d。&#39; %(name, age))print(&#39;胜率%d%%&#39; % 87)  # %% 表示 %  ==&gt; 87%</code></pre><ul><li><strong>input()</strong> 标准输入函数,输入的内容是字符串</li></ul><pre><code class="python">print(&#39;请输入你的姓名：&#39;)input()&lt;==&gt; input(&#39;请输入你的姓名：&#39;)# 保存输入的数据input_content = input(&#39;请输入你的姓名：&#39;)print( input_content)# 动态print(&#39;欢迎您 %s !&#39; % input_content)</code></pre><h2 id="Python-分支语句"><a href="#Python-分支语句" class="headerlink" title="Python 分支语句"></a>Python 分支语句</h2><h3 id="if-分支语句"><a href="#if-分支语句" class="headerlink" title="if 分支语句"></a>if 分支语句</h3><ul><li>比较运算符</li></ul><pre><code>==  相等, !=  不相等, &gt;   大于, &lt;   小于, &gt;=  大于等于, &lt;=  小于等于</code></pre><ul><li>if 语句</li></ul><pre><code class="python">if a &gt; b  :    ret = a -b    else:        ret = a + b        print(ret)</code></pre><ul><li>多个条件之间的关系</li></ul><pre><code class="python"># and(且)  ==&gt; 非 0 为真， 0 为假ret = 0 and 2 # ==&gt; 第一个条件为假，没有必要检查第二个条件 故 输出第一个条件 0ret = 1 and 0 # ==&gt; 第一个条件为真，第二个条件必须执行   输出第二个条件 0ret = 1 and 2 # ==&gt; 第一个条件为真，第二个条件必须执行   输出第二个条件 2# or(或)   ==&gt; 一个为真则为真ret = 1 or 2  # 检查第一个条件，为真， 输出第一个条件 0ret = 0 or 1  # 第一个条件为假，第二个条件必须执行   输出第二个条件 1ret = 0 or 0  # 第一个条件为假，第二个条件必须执行   输出第二个条件 0# 例  and 优先级 高于 ora = 10b = 20ret = a &gt; b and a or b= false and a or b= false or b= b                 # ==&gt; b 20ret = a &lt; b and a or b= true and a or b= a or b= a                 # ==&gt; a 10# not(非)</code></pre><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><pre><code class="python">&quot;&quot;&quot;    我不喜欢这个世界，我只喜欢你！    &quot;&quot;&quot;# while 循环# i = 1# while i &lt;= 100:#     print(i)#     i += 1## print(&#39;END&#39;)# 1-100 偶数# i = 1# while i &lt;= 100:#     # print(i)#     # i += 2#     if i % 2 == 0:#         print(i)#     i += 1# 1-100 累加和# start = 1# end = 100# total = 0# while start &lt;= end:#     total = total + start#     start += 1# print(total)# start = int(input(&#39;开始数：&#39;))# end = int(input(&#39;结束数：&#39;))# total = 0# while start &lt;= end:#     total = total + start#     start += 1# print(total)# 1-100 奇数和# start = 1# total = 0# while start &lt;= 100:#     if start % 2 != 0:#         total = total + start#     start += 1# print(&#39;奇数和：&#39;,total)# 打印 *# n = 1# while n &lt;= 5:#     print(&#39;*&#39; * n)#     n += 1# 1- 100 除 50 不累加# index = 1# total = 0# while index &lt;= 100:#     if index != 50:#         total = total + index#     index += 1# print(total)# index = 1# total = 0# while index &lt;= 100:#     if index == 50:#         index += 1#         continue  # 跳过本次循环 不是退出循环#     total = total + index#     index += 1# print(total)# 大于 50 停止循环# i = 1# while i &lt;= 100:#     if i &gt; 50:#         break  # 后边的代码不执行，并且终止循环#     i += 1# print(i)# 简易版员工管理系统# 1 展示信息# 2 新增信息# 3 修改信息# 4 删除信息# 5 退出while True:    print(&#39;欢迎使用&#39;)    print(&#39;*&#39; * 10 + &#39;操作菜单&#39; + &#39;*&#39; * 10)    print(&#39;1. 展示信息&#39;)    print(&#39;2. 新增信息&#39;)    print(&#39;3. 修改信息&#39;)    print(&#39;4. 删除信息&#39;)    print(&#39;5. 退出&#39;)    # 保存用户操作    user_operation = int(input(&#39;请输入您的操作：&#39;))    if user_operation == 1:        print(&#39;姓名\t年龄\t&#39;)        print(&#39;鲁班\t20\t&#39;)        print(&#39;吕布\t30\t&#39;)        print(&#39;小乔\t18\t&#39;)        elif user_operation == 2:            name = input(&#39;请输入姓名：&#39;)            age = input(&#39;请输入年龄：&#39;)            print(&#39;%s 添加成功&#39;% name)            elif user_operation == 3:                name = input(&#39;请输入修改姓名&#39;)                print(&#39;%s 修改成功&#39;% name)                elif user_operation == 4:                    name = input(&#39;请输入修改姓名&#39;)                    print(&#39;%s 删除成功&#39;% name)                    elif user_operation == 4:                        print(&#39;退出成功&#39;)                        break                        else:                            print(&#39;输入有误&#39;)                            print(&#39;*&#39; * 27)</code></pre><h2 id="Python-函数操作"><a href="#Python-函数操作" class="headerlink" title="Python 函数操作"></a>Python 函数操作</h2><pre><code class="python"># 定义函数：def 函数名():    一行或多行代码# def sum(a, b):#     ret = a + b#     return ret# result =  sum(10, 20)# result = result + 100# print(result)# 两个数之间的所有数之和start = int(input(&#39;输入开始数字：&#39;))end = int(input(&#39;输入结束数字：&#39;))def sum(start, end):    &quot;&quot;&quot;这是我的函数文档&quot;&quot;&quot;    if not isinstance(start, int):        print(&#39;请输入整数&#39;)        return None    if not isinstance(end, int):        print(&#39;请输入整数&#39;)        return None    if start &gt; end:        print(&#39;start 必须小于 end&#39;)        return None    total = 0    whi le start &lt;= end:        total = total + start        start += 1        print(total)        sum(start, end)        # 输入运算符进行计算        while True:            Operator = input(&#39;请输入运算符&#39;)            def Operation(left, right, Oper):                a = left                b = right                if Oper == &#39;+&#39;:                    result = a + b                    elif Oper == &#39;-&#39;:                        result = a - b                        elif Oper == &#39;*&#39;:                            result = a * b                            elif Oper == &#39;/&#39;:                                result = a / b                                else:                                    print(&#39;输入有误&#39;)                                    result = None                                    return result                                result = Operation(10, 20, Operator)                                print(result)</code></pre><h2 id="数据类型基础操作"><a href="#数据类型基础操作" class="headerlink" title="数据类型基础操作"></a>数据类型基础操作</h2><h3 id="字符串（String）-1"><a href="#字符串（String）-1" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><blockquote><p>维度：方法的作用，参数，返回值，原数据是否改变</p></blockquote><h5 id="符串的遍历"><a href="#符串的遍历" class="headerlink" title="符串的遍历"></a>符串的遍历</h5><pre><code class="python">istr = &#39;hello&#39;# 方法一i = 0while i &lt; 5:    print(istr[i])    i += 1    # 方法二    for v in istr:        print(v, end=&#39; &#39;)</code></pre><h5 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h5><ul><li><strong>replace()</strong> [ str.replace(‘old’, ‘new’, 替换次数) ]</li></ul><pre><code class="python">strEmail = &#39;zxymaibox@yeah.net&#39;newstr = strEmail.replace(&#39;y&#39;,&#39;#&#39;) # 将所有的 y 替换成 ‘#’newstr = strEmail.replace(&#39;y&#39;,&#39;#&#39;, 1) # 只替换第一次出现的 y</code></pre><h5 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h5><ul><li><strong>find()</strong></li><li>返回第一次出现的位置，如果没有则返回 -1</li></ul><pre><code class="python">strEmail = &#39;zxymaibox@yeah.net&#39;# 找到 @ 的位置strEmail.find(&#39;@&#39;)</code></pre><h5 id="字符串的切片"><a href="#字符串的切片" class="headerlink" title="字符串的切片"></a>字符串的切片</h5><pre><code class="python"># 以 @ 获取前后内容strEmail = &#39;zxymaibox@yeah.net&#39;possion = strEmail.find(&#39;@&#39;)  # 10# *****************strEmail[起始 : 结束 : 步长]# 起始值不写表示从 0 开始print(strEmail[: 9])# 结束值不写表示到最后print(strEmail[10:])# 步长(第三个值表示步长)print(strEmail[0: 9: 1])  &lt;==&gt; print(strEmail[0 : 9]) # zxymaiboxprint(strEmail[0: 9: 2])  # zyabxprint(strEmail[0: 9: 3])  # zmb# 起始 : 结束 : 步长 可以是负值print(strEmail[9: 1: -1]  # xobiamyxz      # 字符串的逆序      print(strEmail[:: -1])      # *****************      # 切片语法左闭右开      方法一：      username =&gt; print(strEmail[0: 9])      # 获取字符串长度      length = len(strEmail)      houzhui =&gt; print(strEmail[10: length])      方法二：      username = strEmail[:possion]      houzhui = strEmail[possion + 1:]      print(username, houzhui)</code></pre><h5 id="字符串拆分成列表"><a href="#字符串拆分成列表" class="headerlink" title="字符串拆分成列表"></a>字符串拆分成列表</h5><ul><li><strong>split()</strong></li><li>返回拆分后的列表</li></ul><pre><code class="python"># 以 @ 获取前后内容strEmail = &#39;zxymaibox@yeah.net&#39;# 查询某一字符出现的次数strCount = strEmail.count(&#39;@&#39;)if strCount == 1:    result = strEmail.split(&#39;@&#39;)    print(result)  # =&gt; [&#39;zxymaibox&#39;, &#39;yeah.net&#39;]    username = result[0]    houzhui = result[1]</code></pre><h5 id="查询某一字符出现的次数"><a href="#查询某一字符出现的次数" class="headerlink" title="查询某一字符出现的次数"></a>查询某一字符出现的次数</h5><ul><li><strong>count()</strong></li></ul><pre><code class="python">strEmail = &#39;zxymaibox@yeah.net&#39;print(strEmail.count(&#39;@&#39;)) # =&gt; 1print(strEmail.count(&#39;y&#39;)) # =&gt; 2</code></pre><h5 id="判断字符串是否全为字母"><a href="#判断字符串是否全为字母" class="headerlink" title="判断字符串是否全为字母"></a>判断字符串是否全为字母</h5><ul><li><strong>isalpha()</strong> [str.isalpha()]</li><li>返回布尔值</li></ul><h5 id="字符串去除两侧空格"><a href="#字符串去除两侧空格" class="headerlink" title="字符串去除两侧空格"></a>字符串去除两侧空格</h5><ul><li><strong>strip()</strong></li><li>返回新的字符串</li></ul><h3 id="列表（List）-1"><a href="#列表（List）-1" class="headerlink" title="列表（List）"></a>列表（List）</h3><pre><code class="python">list = [10, 20, 30, 40]# 列表支持切片语法,可以切成小列表list[:: -1]</code></pre><h5 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h5><pre><code class="python">list = [10, 20, 30, 40]# 方法一index = 0length = len(list)while index &lt; length:    print(list[index])    index += 1    # 方法二    for val in list:        print(val)</code></pre><h5 id="列表元素插入"><a href="#列表元素插入" class="headerlink" title="列表元素插入"></a>列表元素插入</h5><pre><code class="python">list = [10, 20, 30, 40]# 尾部插入list.append(30)# 指定位置插入list.insert(0, 200)</code></pre><h5 id="列表元素删除"><a href="#列表元素删除" class="headerlink" title="列表元素删除"></a>列表元素删除</h5><ul><li><strong>pop()</strong> 位置删除，[ 无参数的时候，默认删除最后一个位置的元素 ]</li><li><strong>remove()</strong> 值删除， [ 默认删除第一次出现的值 ]</li><li>**clear() **清空列表，</li></ul><pre><code class="python">list = [10, 20, 30, 40, 20]# 位置删除 poplist.pop()list.pop(2)#  值删除list.remove(20)# 列表清空list.clear()</code></pre><h5 id="列表元素查找和修改"><a href="#列表元素查找和修改" class="headerlink" title="列表元素查找和修改"></a>列表元素查找和修改</h5><ul><li><strong>index(oldValue)</strong> [ 如果值存在返回位置，不存在会报错 ]</li><li><strong>count(oldValue)</strong> [ 查找出现的次数，如果不为 0 ，再使用 index 方法 ]</li></ul><pre><code class="python">list = [10, 20, 30, 40]# if list.count(20) != 0:#     indexC = list.index(20)#     # 修改值#     list[indexC] = 20或#  in 和 not in 判断值是否存在if 20 in list:    indexC = list.index(20)    # 修改值    list[indexC] = 20</code></pre><h5 id="列表元素排序"><a href="#列表元素排序" class="headerlink" title="列表元素排序"></a>列表元素排序</h5><ul><li><strong>sort()</strong> [默认从小到大, reverse= false ]</li><li>参数： reverse=True 实现降序排列；</li><li>逆序： reverse() [ 实现列表的逆序 ]</li></ul><pre><code class="python"># 创建一个包含 10 个随机数的列表import randomlist = []i = 0while i &lt; 10:    randomNum =  random.randint(1, 100) # 1-100 的随机数    list.append(randomNum)    i += 1    print(list)    list.sort()</code></pre><h5 id="两个列表元素追加"><a href="#两个列表元素追加" class="headerlink" title="两个列表元素追加"></a>两个列表元素追加</h5><ul><li><strong>extend()</strong></li></ul><pre><code class="python">list1 = [1,2,3,4]list2 = [10,20,30,40]list1.extend(list2)print(list1)  # [1,2,3,4,10,20,30,40]</code></pre><h3 id="元祖（Tuple）"><a href="#元祖（Tuple）" class="headerlink" title="元祖（Tuple）"></a>元祖（Tuple）</h3><p><strong>可以理解为列表，但是他的元素不可修改</strong></p><ul><li>元组一旦创建不可修改</li><li>元组只有一个元素时，需要在尾部添加一个逗号</li><li>元组比列表更节省空间</li><li>元组是序列式容器支持索引、切片操作</li></ul><pre><code class="python"># 定义元组tuple = (10,20,30,40)# 只支持不能修改元素的方法# 查询元素- index- count# 遍历操作- while- for</code></pre><h3 id="字典（Dictionary）-1"><a href="#字典（Dictionary）-1" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><pre><code class="python"># 字典的定义，键是唯一的，值可以重复，不支持索引和切片dict = &#123;    &#39;name&#39;: &#39;serendipity&#39;,    &#39;gender&#39;: &#39;女&#39;    &#39;age&#39; : &#39;20&#39;,&#125;</code></pre><h5 id="字典元素访问"><a href="#字典元素访问" class="headerlink" title="字典元素访问"></a>字典元素访问</h5><pre><code class="python">dict = &#123;    &#39;name&#39;: &#39;serendipity&#39;,    &#39;gender&#39;: &#39;女&#39;    &#39;age&#39; : &#39;20&#39;,&#125;## 获取值1. print(dict[&#39;age&#39;])   # 20 , 不存在会报错2. 使用 get 方法print(dict.get(&#39;age&#39;, &#39;我是默认返回值&#39;))  # 20 , 不存在返回 None , 可以指定默认返回值## 添加和修改元素（如果 key 存在就是修改元素，不存在则添加元素）dict[&#39;score&#39;] = 99       # 添加元素dict[&#39;name&#39;] = &#39;时光静好&#39; # 修改元素</code></pre><h5 id="字典元素删除"><a href="#字典元素删除" class="headerlink" title="字典元素删除"></a>字典元素删除</h5><pre><code class="python">person = &#123;    &#39;name&#39;: &#39;serendipity&#39;,    &#39;gender&#39;: &#39;女&#39;    &#39;age&#39; : &#39;20&#39;,&#125;## 删除元素(也适用于列表)del  person[&#39;age&#39;]## 清空字典person.clear()## 删除整个字典del person</code></pre><h5 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h5><pre><code class="python">person = &#123;    &#39;name&#39;: &#39;serendipity&#39;,    &#39;gender&#39;: &#39;女&#39;    &#39;age&#39; : &#39;20&#39;,&#125;for val in person:    print(val)   # name,gender,age 默认只能遍历键    # ***********************    # 遍历字典的键    personKeyList = person.keys()    print(personKeyList)  # dict_keys 类型： dict_keys([&#39;name&#39;, &#39;gender&#39;, &#39;age&#39;])    # 把 dict_keys 类型 转换 成列表类型    print(list(personKeyList))  # [&#39;name&#39;, &#39;gender&#39;, &#39;age&#39;]    # 遍历字典的值    personValList = person.values()    print(personValList)  # dict_values 类型： dict_values([&#39;serendipity&#39;, &#39;女&#39;, &#39;20&#39;])    # 把 dict_values 类型 转换 成列表类型    print(list(personValList))  # [&#39;serendipity&#39;, &#39;女&#39;, &#39;20&#39;]    # 键值对遍历    personKeyValList = person.items()    print(personKeyValList)  # dict_items 类型： dict_items([(&#39;name&#39;: &#39;serendipity&#39;),(&#39;gender&#39;: &#39;女&#39;), (&#39;age&#39; : &#39;20&#39;)])    # 把 dict_items 类型 转换 成列表类型    print(list(personKeyValList))  # [(&#39;name&#39;: &#39;serendipity&#39;),(&#39;gender&#39;: &#39;女&#39;), (&#39;age&#39; : &#39;20&#39;)]    keyValList = list(person.items())    for value in keyValList:        print(value)        print(&#39;key:&#39;, value[0],&#39;value:&#39;, value[1])        i = 0        while i &lt; len(keyValList):            print(&#39;key:&#39;, keyValList[i][0], &#39;value:&#39;, keyValList[i][1] )            i += 1</code></pre><h3 id="集合（Set）-1"><a href="#集合（Set）-1" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><h2 id="Python-文件操作"><a href="#Python-文件操作" class="headerlink" title="Python 文件操作"></a>Python 文件操作</h2><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><ul><li><strong>open(文件名, 访问模式)</strong> 打开文件 [ 参数： 文件名 ， 访问模式]<ul><li>访问模式： r 以只读方式打开文件（默认）</li><li>访问模式： w 打开文件只用于写入</li><li>访问模式： a 打开文件用于追加，文件存在，新的内容写入已有内容之后，文件不存在，创建新文件进行写入</li><li>访问模式： rb 以二进制格式打开文件用于只读，文件指针放在开头</li><li>访问模式： wb 以二进制格式打开文件用于写入，文件存在，将其覆盖，文件不存在，创建新文件进行写入</li><li>访问模式： wb 以二进制格式打开文件用于追加，文件存在，新的内容写入已有内容之后，文件不存在，创建新文件进行写入</li></ul></li><li><strong>close()</strong> 关闭文件</li></ul><p>** pyCharm 文件编码: file encodings: GBK **</p><pre><code class="python">#  写入文件fileA= open(&#39;test.md&#39;, &#39;w&#39;) # 参数 文件名， 访问模式content= &quot;1. 时光静好，岁月安然 \n 一人之间，山水江湖&quot;fileA.write(content)# 关闭文件fileA.close()# 读取文件fileB= open(&#39;test.md&#39;, &#39;r&#39;)content = fileB.read()print(content)fileB.close()</code></pre><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><ul><li><strong>write()</strong>         一次只可以写一行</li><li><strong>writelines()</strong>  一次写入多行，以列表形式</li><li><strong>read()</strong>         没有参数读取文件所有数据，指定参数（1,2,3… …）读取指定个数的数据</li><li><strong>readline()</strong>    一次读取一行</li><li><strong>readlines()</strong>   一次读取多行</li></ul><pre><code class="python">#  写入文件fileA= open(&#39;test.md&#39;, &#39;w&#39;) # 参数 文件名， 访问模式content= &quot;1. 时光静好，岁月安然 \n 一人之间，山水江湖!&quot;fileA.write(content)lines = [&#39;时光静好，岁月安然.\n&#39;, &#39;一人之间，山水江湖!\n&#39;]fileA.writelines(lines)# 关闭文件fileA.close()## 读取文件fileB= open(&#39;test.md&#39;, &#39;r&#39;)&quot;&quot;&quot;文件内容:    时光静好，岁月安然.    一人之间，山水江湖!    &quot;&quot;&quot;content = fileB.read()content1 = fileB.readline()content2 = fileB.readline()content4 = fileB.readlines()print(content)  # 读取所有内容print(content1) # 时光静好，岁月安然.print(content2) # 一人之间，山水江湖!(因为第一行content1 已经读过，所以读取下一行内容)print(content4) # [&#39;时光静好，岁月安然.\n&#39;, &#39;一人之间，山水江湖!\n&#39;]# 按行读取for line in content4:    if line[-1] == &#39;\n&#39;:        print(line[:-1])        else:             print(line)            fileB.close()</code></pre><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><pre><code class="python"># 获取要拷贝的文件名old_fileName = input(&#39;请输入您要拷贝的文件名：&#39;)# 读取拷贝文件内容new_fileName = old_fileName + &#39;bk&#39;# 打开新的文件file_old = open(old_fileName, &#39;rb&#39;)file_new = open(new_fileName, &#39;wb&#39;) # 将老文件内容写入新文件old_fileContent = file_old.read()file_new.write(old_fileContent)# 关闭文件file_old.close()file_new.close()</code></pre><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><pre><code class="python">import os# 文件重命名os.rename(&#39;test.md&#39;, &#39;hello.txt&#39;)# 文件删除os.remove(&#39;test.md&#39;) # 路径问题：写绝对路径# 创建和删除目录os.mkdir(&#39;abc&#39;)os.rmdir(&#39;abc&#39;)# 获取目录的文件列表os.listdir(&#39;abc&#39;)# 获取和设置工作目录os.getCWD()  # CWD 默认当前文件路径os.chdir(&#39;\Users\YII\Desktop\\&#39;) # 设置默认工作目录</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端领域</category>
      
      <category>编程语言</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Locust 性能测试</title>
    <link href="/alwaysblog/post/519960898/"/>
    <url>/alwaysblog/post/519960898/</url>
    
    <content type="html"><![CDATA[<h2 id="Locust-安装及运行"><a href="#Locust-安装及运行" class="headerlink" title="Locust 安装及运行"></a>Locust 安装及运行</h2><ul><li>创建虚拟环境，并进入</li></ul><pre><code class="shell">$ pip install locustio==0.14.6  (0.14.6 版本安装)$ pip install locust  (最新版本安装)$$ 报错： error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/ Tools&quot;$ 解决： http://go.microsoft.com/fwlink/?LinkId=691126$ 导入win32com模块还失败，执行下面命令$    python -m pip install pypiwin32</code></pre><ul><li>脚本运行</li></ul><pre><code class="shell">$ locust -f ***.py    运行成功：$ (locust_0) D:\Locust\locust_0\src&gt;locust -f locust0-template.py$ [2020-08-16 21:16:56,219] Yii/INFO/locust.main: Starting web monitor at http://*:8089$ [2020-08-16 21:16:56,219] Yii/INFO/locust.main: Starting Locust 0.14.6    </code></pre><ul><li>浏览器访问</li></ul><pre><code class="shell">本机访问： localhost:8089  远程访问： ip / 域名：8089    Number of total users to simulate： 模拟的总数量 20/200/2000    Hatch rate (users spawned/second)： 每秒增加多少个用户     Host： 被测的服务器的 IP和端口 / 域名（http://8.129.219.235:8808）</code></pre><h2 id="Locust-运行模式"><a href="#Locust-运行模式" class="headerlink" title="Locust 运行模式"></a>Locust 运行模式</h2><h4 id="Web-界面启动-单进程"><a href="#Web-界面启动-单进程" class="headerlink" title="Web 界面启动 (单进程)"></a>Web 界面启动 (单进程)</h4><blockquote><p>参数：<br>   –web-host: HOST<br>  –web-port: PORT</p></blockquote><pre><code class="shell">    locust --web-host=127.0.0.1 --web-port=8088 -f .\\1000_user_load_query.py</code></pre><h4 id="命令行启动-单进程"><a href="#命令行启动-单进程" class="headerlink" title="命令行启动 (单进程)"></a>命令行启动 (单进程)</h4><blockquote><p>参数：<br>   –headless : 禁用 Web 界面，且立即开始负载测试 需要 -u 和 -t 被指定<br>     –host : 地址 <a href="http://192.168.40.1:8090/" rel="external nofollow noreferrer">http://192.168.40.1:8090</a> (<a href="https://www.baidu.com/" rel="external nofollow noreferrer">https://www.baidu.com</a>)<br>   –csv : 保存执行结果  –csv=result<br>     -u/–users : 虚拟用户数<br>     -r/–spawn-rate : 每秒孵化数（每秒增加用户数）<br>   -t/–run-time ： 运行时间（h, m, s, 1h30m）</p></blockquote><pre><code class="shell">    locust -f 1000_user_load_query.py --headless --host=http://192.168.40.1:8090 --csv=./result/result  --u 200 -r 20 -t 60s</code></pre><h4 id="分布式运行（多进程）"><a href="#分布式运行（多进程）" class="headerlink" title="分布式运行（多进程）"></a>分布式运行（多进程）</h4><blockquote><p>角色： </p><ol><li>主机： –master; 只负责管理不运行脚本</li><li>从属主机(执行机)： –worker –master-host=主机 IP</li></ol><p>注意：  </p><ol><li>执行机必须有主机脚本的副本     2. 同一台机子执行, 处理器的核心数就是执行机的最大数量<br>参数：    –master :     –web-host: 访问 IP</li></ol><p>   –web-port: 端口号<br>      –master-bind-host : 要绑定的主机名，IP; 仅在 master 时使用,可以不使用<br>      –master-bind-port : 要绑定的主机端口号; 仅在 master 时使用,可以不使用<br>    –expect-workers : 执行机数量 仅在 headless 时使用</p><p>  –worker : 如果 master 和 worker 不在同一台机器上， worker 需要指定 –master-host 参数<br>  –master-host : 运行 master 时设置的 host<br>  –master-port : 运行 master 时设置的 port</p></blockquote><ul><li>Web 界面启动<br>```shell</li></ul><h1 id="主机启动"><a href="#主机启动" class="headerlink" title="主机启动"></a>主机启动</h1><pre><code>locust -f 1000_user_load_query.py --master --web-host=192.168.40.1</code></pre><h1 id="从机启动（每次启动一个执行机）"><a href="#从机启动（每次启动一个执行机）" class="headerlink" title="从机启动（每次启动一个执行机）"></a>从机启动（每次启动一个执行机）</h1><pre><code>locust -f .\\1000_user_load_query.py --worker --master-host=主机 IP  </code></pre><p>```</p><h2 id="FastHttpUser-和-HttpUser"><a href="#FastHttpUser-和-HttpUser" class="headerlink" title="FastHttpUser 和 HttpUser"></a>FastHttpUser 和 HttpUser</h2><blockquote><p>FastHttpUser<br>HttpUser</p></blockquote><h2 id="Locust-geventhttpclient"><a href="#Locust-geventhttpclient" class="headerlink" title="Locust + geventhttpclient"></a>Locust + geventhttpclient</h2><blockquote><p>geventhttpclient</p></blockquote><h2 id="SequentialTaskSet-和-TaskSet"><a href="#SequentialTaskSet-和-TaskSet" class="headerlink" title="SequentialTaskSet 和 TaskSet"></a>SequentialTaskSet 和 TaskSet</h2><blockquote><p>SequentialTaskSet<br>TaskSet</p></blockquote><h2 id="Locust-多进程-数据共享"><a href="#Locust-多进程-数据共享" class="headerlink" title="Locust 多进程 数据共享"></a>Locust 多进程 数据共享</h2><blockquote></blockquote><h2 id="Locust-运行-Go-语言"><a href="#Locust-运行-Go-语言" class="headerlink" title="Locust 运行 Go 语言"></a>Locust 运行 Go 语言</h2><blockquote><p>使用 Locust + Go 实现性能测试， 比 py 脚本性能提高到 5 - 10 倍<br>待研究。。。。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
      <category>性能测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>性能测试</tag>
      
      <tag>locust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能测试基础</title>
    <link href="/alwaysblog/post/3113662073/"/>
    <url>/alwaysblog/post/3113662073/</url>
    
    <content type="html"><![CDATA[<h2 id="性能测试理论知识"><a href="#性能测试理论知识" class="headerlink" title="性能测试理论知识"></a>性能测试理论知识</h2><p><strong>性能测试的目的：发现性能的瓶颈</strong></p><h3 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h3><pre><code>通过逐步加压的方法，达到既定的性能阀值的目标。    阀值的设定应是小于等于某个值,如 CPU 的使用率小于等于 80%</code></pre><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><pre><code>通过逐步加压的方法，使系统的某些资源达到饱和，甚至失效的状态（也就是说什么条件下可以把系统压崩溃）</code></pre><h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><pre><code>同一时间内，多个虚拟用户同时访问同一模块、同一功能。通常的测试方法是设置集合点。</code></pre><h3 id="容量测试"><a href="#容量测试" class="headerlink" title="容量测试"></a>容量测试</h3><pre><code>通常是指数据库层面的，目标是获取数据库最佳容量的能力，又称为容量预估。    测试方法：在一定的并发用户，不同的基础数据量下，观察数据库的处理能力，即获取数据库的各项性能指标</code></pre><h3 id="可靠性测试（稳定性测试-疲劳测试）"><a href="#可靠性测试（稳定性测试-疲劳测试）" class="headerlink" title="可靠性测试（稳定性测试 / 疲劳测试）"></a>可靠性测试（稳定性测试 / 疲劳测试）</h3><pre><code>系统在高压的情况下，长时间的运行系统是否稳定。    如 CPU 使用率在 80% 以上，7 * 24 小时运行，系统是否稳定</code></pre><h3 id="异常测试（失败测试）"><a href="#异常测试（失败测试）" class="headerlink" title="异常测试（失败测试）"></a>异常测试（失败测试）</h3><pre><code>指系统架构方面的测试，如：在负载均衡架构中，要测试宕机（死机）、节点挂掉等情况下系统的反应。</code></pre><h3 id="性能测试指标定义"><a href="#性能测试指标定义" class="headerlink" title="性能测试指标定义"></a>性能测试指标定义</h3><ul><li>事务</li></ul><pre><code>从客户端发起的一个或多个请求(这些请求组成一个完整的操作)，到客户端接收到从服务器返回的响应。</code></pre><ul><li>TPS (Transactions Per Second)</li></ul><pre><code>每秒钟系统可以处理的事务数</code></pre><ul><li>QPS：(Query per second )</li></ul><pre><code>一台查询服务器每秒处理的请求次数</code></pre><ul><li>请求响应时间</li></ul><pre><code>从客户端发起的一个请求开始，到客户端接收到从服务器返回的响应。整个过程所耗费的时间</code></pre><ul><li>事务响应时间</li></ul><pre><code>事务可能有一个或多个请求组成，事务的响应时间主要针对于用户的角度而言，如转账。</code></pre><ul><li>并发定义</li></ul><pre><code>没有严格意义上的并发，并发总有先后，无论是差距 1 毫秒或者是 1 微秒，总有一个时间差。所以并发讲的是一个时间范围内，比如 1S 内。</code></pre><ul><li>并发用户数</li></ul><pre><code>同一单位时间内，对系统发起请求的用户数量</code></pre><ul><li>吞吐量</li></ul><pre><code>一次性能测试过程中，网络上传输的数据量的总和</code></pre><ul><li>吞吐率</li></ul><pre><code>单位时间内网络上传输的数据量吞吐率 = 吞吐量 / 吞吐时间</code></pre><ul><li>点击率</li></ul><pre><code>每秒钟用户向服务器提交的请求数。Web 应用程序特有的指标，</code></pre><ul><li>资源使用率</li></ul><pre><code>对不同的系统资源的使用情况，如： CPU、内存、 IO</code></pre><h3 id="性能测试的监控指标"><a href="#性能测试的监控指标" class="headerlink" title="性能测试的监控指标"></a>性能测试的监控指标</h3><ul><li>响应时间</li></ul><pre><code>反映完成某笔业务（事务）所需要的时间。在性能测试中通过事务函数来完成对响应时间的统计，事务是指做某件事的操作，事务函数会记录开始做这件事情和该事情完成之间的时间差（事务响应时间 Transaction Response Time）    其他：    1. 响应时间的2、5、8原则    2. 80/20原则（又称帕累托效应，比如，某些系统一天中80%的访问量集中在20%的时间内）</code></pre><ul><li>吞吐量</li></ul><pre><code>反映单位时间内能够处理的事务数。在测试工具中，吞吐量也被称为TPS，单位时间内完成的事务数。TPS = 事务数 / 时间</code></pre><ul><li>服务器资源占用</li></ul><pre><code>服务器资源占用反映在负载下系统的资源利用率。资源的占用率越低，说明系统越优秀，资源是指系统运行的一切软硬件平台。在性能测试中，我们需要监控系统在负载下的硬件或者软件上的各种资源的使用情况，如：CPU的占用率、内存使用率、IO等（数据库中的查询Cache命中率）。对于终端用户来讲，其最关心的指标是响应时间。用户并不关心多少人使用，以及资源是否足够，所以性能测试必须保证在任意情况下终端用户使用的操作响应时间不大于5秒。</code></pre><h3 id="性能测试的原理"><a href="#性能测试的原理" class="headerlink" title="性能测试的原理"></a>性能测试的原理</h3><ul><li>用户行为模拟</li></ul><pre><code>低成本且具有可行性，模拟大量用户操作的一种技术，凭借此项技术将被测系统在测试阶段运行起来，以检测系统工作是否正常。    1. 通过参数化，实现不同用户使用不同数据     1. 通过集合点模拟多用户并发操作    2. 通过关联实现用户请求间的依赖关系    3. 通过思考时间代替请求间的延时时间</code></pre><ul><li>性能指标监控</li></ul><pre><code>通过模拟用户行为，在系统运行中需要监控各项性能指标，并分析指标正确性    1. 请求响应时间（通过事务实现 ）    2. 服务器处理能力监控（通过事务计算吞吐量）    3. 服务器资源利用率监控（计数器接口）</code></pre><ul><li>性能调优</li></ul><pre><code>通过指标的监控发现系统存在的性能缺陷，利用分析工具定位并修正性能问题。</code></pre><h2 id="性能测试的工作流程"><a href="#性能测试的工作流程" class="headerlink" title="性能测试的工作流程"></a>性能测试的工作流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/518310/1598235372090-03e1cf57-25a2-4416-8850-168cf6f21260.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=767&size=0&status=done&style=none&width=767"></p><h3 id="性能测试的需求分析"><a href="#性能测试的需求分析" class="headerlink" title="性能测试的需求分析"></a>性能测试的需求分析</h3><ul><li>目的: 明确测试目标和测试场景</li><li>新系统<ul><li>同行业比较</li><li>业务预期</li></ul></li><li>老系统<ul><li>对比以往用户的使用行为以及用户量</li></ul></li><li>性能需求的的提取</li></ul><pre><code>1. 典型重要业务场景2. 高频使用场景3. 存在大量并发业务场景4. 容易出错的场景</code></pre><h3 id="系统应用分层架构"><a href="#系统应用分层架构" class="headerlink" title="系统应用分层架构"></a>系统应用分层架构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/518310/1598235371396-5205c275-4e4a-4807-985f-4920bfd9bc79.png#align=left&display=inline&height=438&margin=%5Bobject%20Object%5D&originHeight=438&originWidth=832&size=0&status=done&style=none&width=832"></p><h2 id="JMeter-性能测试"><a href="#JMeter-性能测试" class="headerlink" title="JMeter 性能测试"></a>JMeter 性能测试</h2><h3 id="JMeter-实现逻辑分支控制"><a href="#JMeter-实现逻辑分支控制" class="headerlink" title="JMeter 实现逻辑分支控制"></a>JMeter 实现逻辑分支控制</h3><ul><li>逻辑控制器<ul><li>用来控制测试脚本的逻辑判断，即控制脚本的运行(以下为常用控制器)</li><li>如果（if）控制器</li><li>include Controller</li><li>Runtime Controller</li><li>Switch Controller</li><li>While Controller</li></ul></li></ul><h3 id="JMeter-实现配置管理"><a href="#JMeter-实现配置管理" class="headerlink" title="JMeter 实现配置管理"></a>JMeter 实现配置管理</h3><ul><li>配置元件</li></ul><h3 id="JMeter-函数助手"><a href="#JMeter-函数助手" class="headerlink" title="JMeter 函数助手"></a>JMeter 函数助手</h3><ul><li>_CSVRead: 用于对脚本进行参数话，当脚本中不同变量需要不同参数值时</li></ul><pre><code>_CSVRead 函数参数说明：CSV file to get values from | *alias ==&gt; 指$&#123;__CSVRead(,)&#125;中（）内的第一个参数，调用文件logins.txt的路径Column number of CSV file | next | *alias ==&gt; 指$&#123;__CSVRead(,)&#125;中（）内的第二个参数，调用文件logins.txt中第几列的参数，注意第一列为0，第二列为1，依此类推。。。生成的函数字符串： $&#123;__CSVRead(C:\Users\234652\Desktop\JMeter\log\01.txt,5)&#125;[ 使用方法 ]： 配合 配置元件用户定义的变量使用</code></pre><ul><li>_Random： 生成随机数</li></ul><pre><code>_Random 函数参数说明：    The minimum value allowed for a range of values ==&gt; 一个范围内允许的最小的值   1    The maximum value allowed for a range of values ==&gt; 一个范围内允许的最大的值   100    Name of variable in which to store the result (optional) ==&gt; 为生成随机数添加变量名称   id(可任意)    生成的函数字符串：$&#123;__Random(2,100,)&#125;  ==&gt; id = 55(随机数)</code></pre><ul><li>_Log：</li></ul><pre><code>log 函数参数说明：    String to be logged (and returned) ==&gt; 日志输出的内容，可以引用变量名称    Log level (default INFO) or OUT or ERR ==&gt; 定义日志输出的级别，INFO、OUT、warn    Throwable text (optional) ==&gt; 抛出的异常信息</code></pre><ul><li>_Split： 字符串分割函数</li></ul><h3 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h3><ul><li>Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值</li><li>#Samples：请求数——表示这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100</li><li>Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，以 Transaction 为单位显示平均响应时间</li><li>Median：中位数，也就是 50％ 用户的响应时间</li><li>90% Line：90％ 用户的响应时间</li><li>Min：最小响应时间</li><li>Max：最大响应时间</li><li>Error%：错误率 —— 错误请求数 / 请求总数</li><li>Throughput：吞吐量——默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数</li><li>KB/Sec：每秒从服务器端接收到的数据量，相当于 LoadRunner 中的 Throughput / Sec</li></ul><p><strong>重点关注的数据：</strong></p><ul><li>Samples： 请求数</li><li>Average： 平均响应时间</li><li>Min： 最小响应时间</li><li>Max： 最大响应时间</li><li>Error%： 错误率</li><li>Throughput： 吞吐量</li></ul><h3 id="JMeter-扩展组件开发"><a href="#JMeter-扩展组件开发" class="headerlink" title="JMeter 扩展组件开发"></a>JMeter 扩展组件开发</h3><pre><code class="shell">$ Git 地址：</code></pre><h2 id="Linux-服务器监控性能测试"><a href="#Linux-服务器监控性能测试" class="headerlink" title="Linux 服务器监控性能测试"></a>Linux 服务器监控性能测试</h2><h3 id="测试范围及性能指标"><a href="#测试范围及性能指标" class="headerlink" title="测试范围及性能指标"></a>测试范围及性能指标</h3><p><strong>—— —— CPU 内存 磁盘 网络 版本</strong></p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程： 具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。（进程是可以独立运行的）</li><li>线程： 是进程的一个实体，是 CPU 调度和分派的基本单位他是比进程更小的能够独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。一个线程可以创建和撤销另一个线程</li></ul><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><ol><li>一个线程只属于一个进程，一个进程中可以拥有多个线程，线程之间可以互相操作。</li><li>线程是进程工作的最小单位，</li><li>一个进程会分配一个地址空间，进程与进程之间不共享地址空间。即不共享内存。</li><li>同一个进程下的不同的多个线程，共享父进程的地址空间。</li><li>线程在执行过程中，需要协作同步，不同进程的线程之间要利用消息通信的办法实现同步。</li><li>线程作为调度和分派的基本单位，进程作为拥有资源的基本单位</li></ol><h4 id="进程的优缺点"><a href="#进程的优缺点" class="headerlink" title="进程的优缺点"></a>进程的优缺点</h4><p>[ 优点 ]</p><ul><li>每个进程互相独立，不影响主程序的稳定性，子进程崩溃不影响其他进程</li><li>通过添加 CPU 可以扩充性能</li><li>可以尽量减少线程加锁和解锁的影响，极大地提高了性能</li></ul><p>[ 缺点 ]</p><ul><li>逻辑控制复杂，需要和主程序交互</li><li>多进程调度开销大</li></ul><h4 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h4><p>[ 优点 ]</p><ul><li>程序的逻辑和控制方式简单</li><li>所有线程可以共享内存和变量等</li><li>线程方式消耗的总资源比进程方式少</li></ul><p>[ 缺点 ]</p><ul><li>线程与主程序共用地址空间，最大内存地址受限</li><li>线程之间的同步和加锁不易控制（同步锁）</li><li>一个线程的崩溃可能影响整个程序的稳定性</li></ul><h3 id="Linux-服务器监控命令"><a href="#Linux-服务器监控命令" class="headerlink" title="Linux 服务器监控命令"></a>Linux 服务器监控命令</h3><h4 id="实时监控命令"><a href="#实时监控命令" class="headerlink" title="实时监控命令"></a>实时监控命令</h4><ul><li>top (实时监控-综合)<ul><li>作用： 实时监控系统的运行状态，并且可以按照 CPU 及内存进行排序</li><li>top -h：帮助</li><li>top -p: 监控指定进程，当监控多个进程是，进程 ID 以逗号分隔。语法：top -p PID</li></ul></li><li>top 任务区命令(top 进入任务区)<ul><li>M：按内存使用率排序</li><li>P: 按 CPU 使用率排序</li><li>z: 彩色 / 黑白显示</li></ul></li></ul><pre><code>load average 说明：    1. top 中的 load average 表示系统运行队列的平均利用率，也可以认为是可运行进程的平均数    2. 三个值分别表示： 1 分钟、5 分钟、15 分钟的平均负载值    3. 在单核 CPU 中 load average 的值为 1 时，表示满负荷状态。    4. 同理，在多核 CPU 中满负载 load average 的值为 1 * CPU 核数。</code></pre><ul><li>vmstat（实时监控 - 综合）<ul><li>功能：可以监控操作系统的进程状态、内存、虚拟内存、磁盘 IO、CPU 的信息</li><li>选项：vmstat -S 使用指定单位显示，（k, K, m, M 分别代表 1000, 1024, 1000000, 1048576 字节，默认单位 K 1024）</li><li>语法：vmstat 2 5 （2 表示时间间隔； 5 表示 显示次数）</li></ul></li><li>free (实时监控-内存)<ul><li>功能：监控系统内存的使用状态</li><li>语法：free -h</li></ul></li></ul><pre><code>free - h 显示字段说明：    1. total： 总物理内存的大小    2. Used： 已经使用多大    3. Free: 可用多少    4. shared: 多个进程共享的内存总额    5. buffers/cached: 磁盘缓存的大小</code></pre><ul><li>mpstat（实时监控 - CPU）<ul><li>功能：可以查看多核心 CPU 中每个计算核心的统计数据</li><li>参数：无参数时，显示系统启动以后所有信息的平均值，有 interval 时，第一行的信息自系统启动以来的平均信息，从第二行开始，输出为前一个 interval 时间段的平均信息</li><li>语法：mpstat [-P | ALL] [interval | count]</li></ul></li></ul><pre><code>mpstat 语法使用说明    1. -P: 表示监控那个 CPU ;在 [0, CPU 个数减一] 中取值    使用方法：mpstat -P 0（实时监控第一个 CPU）; mpstat -P 2(实时监控第三个 CPU);    2. interval 相邻两次采样的间隔事件; count 采样的次数，count 只能和 delay 一起使用    使用方法：mpstat 2 5 （2 表示时间间隔； 5 表示 显示次数）</code></pre><ul><li>netstat (实时监控 - 网络) （netstat -ntlp 查看端口有没有被监听）<ul><li>netstat -n 拒绝显示别名，能显示数字的全部显示数字</li><li>netstat -l 仅列出有在 Listen（监听）的服务状态</li><li>netstat -p 显示建立相关链接的程序名</li><li>netstat -t 显示 TCP 相关选项</li><li>netstat -u 仅显示 UDP 相关选项</li><li>netstat -i 显示自动匹配接口的信息 ==&gt; 查看网络传输的大小以及有没有发生错误</li><li>netstat -c 每隔一个固定时间，执行该 netstat 命令</li></ul></li><li>iostat (实时监控 - 磁盘)<ul><li>作用： 显示磁盘读写操作的统计信息，同时给出 CPU 的使用情况</li><li>iostat -x [设备名称] 1 2 输出指定要统计的磁盘设备名称，默认为所有磁盘设备（1，表示间隔时间，2 表示执行次数）</li></ul></li></ul><pre><code class="shell">[root@dahuatech ~]# iostat -x    Linux 2.6.32-573.el6.x86_64 (dahuatech)         07/28/2020      _x86_64_        (8 CPU)    avg-cpu:  %user   %nice %system %iowait  %steal   %idle    15.64    0.15   14.30    0.48    0.00   69.43    Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util    sda               0.60   241.21    0.68   14.04    64.67  2041.76   143.15     0.09    6.17   1.37   2.01    dm-0              0.00     0.00    0.55    1.49     4.39    11.91     8.00     0.01    5.44   0.34   0.07    dm-1              0.00     0.00    0.00    0.00     0.01     0.00     7.94     0.00    3.88   1.21   0.00    dm-2              0.00     0.00    0.01  152.33     0.07  1218.60     8.00     1.56   10.24   0.03   0.39    dm-3              0.00     0.00    0.17    0.00    27.40     0.00   159.85     0.00    1.91   1.45   0.02    dm-4              0.00     0.00    0.16   97.30     9.72   778.39     8.09     0.26    2.69   0.08   0.77    重点关注： r/s 、w/s、 %util(繁忙程度)    &gt;&gt; 将命令结果以二进制格式存放在文件中</code></pre><ul><li>sar 万能命令<ul><li>功能：linux 全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告</li><li>监控范围： 文件读写情况、系统调用的使用情况、磁盘 I/O 、CPU 效率、内存使用情况、进程活动、IPC 有关的活动</li><li>语法：sar [options] [-O file] t n ==&gt; (options: 命令行选项 t：表示采样间隔时间（必有）；n：表示采样次数（可选，默认 1); -o file: 表示将命令结果以二进制格式存放在文件中，file 表示文件名)</li></ul></li></ul><pre><code class="shell">options 选项：     -A: 所有报告的总和；     -u: CPU 利用率；     -v: 进程、节点、文件和锁表的状态；     -r：显示系统内存的使用情况    -B: 内存分页情况    -b: 缓冲区使用情况（8 份区域）</code></pre><h4 id="进程追踪命令"><a href="#进程追踪命令" class="headerlink" title="进程追踪命令"></a>进程追踪命令</h4><ul><li>strace<ul><li>功能：集诊断、调试、统计于一体的工具，追踪进程的运行过程</li><li>选项 -p： 跟踪指定进程</li><li>选项 -f: 跟踪由 fork 子进程系统调用</li><li>选项 -c: 统计每一系统调用的所执行的时间，次数和出错的次数等</li><li>选项 -t: 在输出中的每一行前加上时间信息， -tt 时间确定到微秒级</li><li>选项 -e expr: 输出过滤器，通过表达式，可以过滤掉不想要的输出</li><li>选项 -o filename: 默认将结果输出到 stdout,通过 -o 输出到指定文件夹</li></ul></li></ul><h4 id="监控工具-nmon"><a href="#监控工具-nmon" class="headerlink" title="监控工具 nmon"></a>监控工具 nmon</h4><pre><code>说明：下载：    wget</code></pre><h2 id="数据驱动性能测试"><a href="#数据驱动性能测试" class="headerlink" title="数据驱动性能测试"></a>数据驱动性能测试</h2><pre><code>定义：从数据文件中读取测试数据，驱动测试过程的一种测试方法（更高级的参数化）。特点：    1. 测试数据与测试代码分离    2. 数据控制过程    3. 可以减少测试代码量    4. 降低脚本开发和维护的成本    5. 便于用例的修改和维护要求：    1. 较强的代码能力    2. 较强的分层架构设计思维    3. 对开发框架有一定的了解使用场景：     1. 复杂的业务流程    2. 根据业务场景分流    3. 符合条件的并发场景</code></pre><h2 id="数据库的架构设计"><a href="#数据库的架构设计" class="headerlink" title="数据库的架构设计"></a>数据库的架构设计</h2><h3 id="数据库性能测试"><a href="#数据库性能测试" class="headerlink" title="数据库性能测试"></a>数据库性能测试</h3><ul><li>测试范围</li></ul><pre><code>1. SQL 语句   =&gt; 慢查询等2. 资源使用率3. 数据库架构的合理性4. 数据库的性能指标</code></pre><h3 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h3><ul><li>一主多从</li></ul><pre><code>读写分离：    master(主写，主库)    ==&gt;复制 slave(从读，从库)    ==&gt;复制 slave(从读，从库)缺点： 主从延迟</code></pre><ul><li>双机热备</li></ul><pre><code>KeepAlived    ==&gt; VIP (虚拟 IP)    ==&gt; master  ==&gt; 复制 ==&gt; slave缺点：优点：</code></pre><h3 id="数据库主从同步的工作原理"><a href="#数据库主从同步的工作原理" class="headerlink" title="数据库主从同步的工作原理"></a>数据库主从同步的工作原理</h3><pre><code>1. master 将改变记录到二进制（binary log 文件）中2. slave 将 master 的 binary log events 拷贝到它的中继日志（relay log，转换日志）3. slave 重做中继日志中的事件，将改变反映他自己的数据</code></pre><h3 id="数据库分库分表的设计方法"><a href="#数据库分库分表的设计方法" class="headerlink" title="数据库分库分表的设计方法"></a>数据库分库分表的设计方法</h3><pre><code>分库分表原因：    1. 单表或库数据量太大    2. 硬件不能升级或无法升级方案：    1. 业务拆分（用户、商品、订单、 ... ...）    2. 垂直拆分（商品 ==&gt; 电子商品、母婴商品、 ... ...）    3. 水平拆分(一致性哈西算法)    usreid  ==&gt; userid%3 == 1            ==&gt; userid%3 == 2            ==&gt; userid%3 == 3</code></pre><h2 id="数据库性能测试-1"><a href="#数据库性能测试-1" class="headerlink" title="数据库性能测试"></a>数据库性能测试</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li>MariaDB(主流分支)<ul><li>MySQL 之父 Widenius 创建，目标在于替换现有的 MySQL</li><li>兼容 MySQL, 对于开发者来说感知不到变化</li><li>MariaDB is free and open source software</li></ul></li></ul><h3 id="MySQL-数据库监控指标"><a href="#MySQL-数据库监控指标" class="headerlink" title="MySQL 数据库监控指标"></a>MySQL 数据库监控指标</h3><ul><li>QPS(Queries per seconds)<ul><li>每秒钟查询数量</li><li>show global status like ‘Question%’;</li></ul></li><li>TPS (Transactions Per Second) TPS = Com_commit + Com_rollback) / seconds<ul><li>show global status like ‘Com_commit’;</li><li>show global status like ‘Com_rollback’;</li></ul></li><li>线程连接数<ul><li>show global status like ‘Max_used_connections’;(使用的最大连接数)</li><li>show global status like ‘Max_connections’;(设置的最大连接数)</li><li>show global status like ‘Threads%’;</li></ul></li><li>Query Cache<ul><li>查询缓存，用于缓存 select 查询结果</li><li>当下次接收到相同查询请求时，不在执行实际查询处理而直接返回结果</li><li>适用于大量查询，很少改变表中的数据</li></ul></li><li>Query Cache 命中率（MySQL 特有）<ul><li>show global status like ‘Qcache%’;</li><li>命中率计算：Query_cache_hits = (Qcahce_hits/(Qcahce_hits + Qcahce_inserts)) * 100%</li></ul></li></ul><pre><code>开启：1. 修改 my.cnf 文件2. 将 query_cache_size 设置为具体的大小（取决于查询的实际情况，最好设置为 1024 的倍数，参考值 32M）3. 增加一行: query_cache_type = 0/1/2    =&gt; 1 表示缓存所有结果，除非你的 select 语句使用 SQL_NO_CACHE 禁用了查询缓存    =&gt; 2 表示只缓存在 select 语句中通过 SQL_CACHE 指定需要缓存的查询</code></pre><ul><li>锁定状态<ul><li>show global status like ‘%lock’;</li><li>table_locks_waited / table_lockks_immediate 值越大代表表锁造成的阻塞越严重</li><li>innodb_row_lock_waits innodb 行锁,太大可能是间隙锁造成的</li><li>表锁、行锁、间隙锁</li></ul></li><li>主从延时<ul><li>查询主从延时时间： show slave status</li></ul></li></ul><h3 id="MySQL-慢查询工作原理及操作"><a href="#MySQL-慢查询工作原理及操作" class="headerlink" title="MySQL 慢查询工作原理及操作"></a>MySQL 慢查询工作原理及操作</h3><pre><code>慢查询：    1. 执行速度超过定义的时间的查询    2. 不同系统定义不同的慢查询指标慢查询开启：    1. 编辑 etc/my.cnf 在 [mysqlid] 域中添加：    slow_query_log = 1 (开启慢查询)    2. 设置慢查询日志路径：    slow_query_log_file = /data/mysql/slow.log    3. 设置慢查询的时长    long_query_time = 1    4. 未使用索引的查询也被记录到慢查询日志中    log_queries_not_using_indexes = 1</code></pre><ul><li>慢查询日志分析<ul><li>mysqldumpslow 命令</li><li>-s : 表示按照何种方式排序</li><li>-t : top n 的意思，即返回前面多少条数据</li><li>-g : 后边可写正则匹配模式，大小写不敏感</li></ul></li><li>mysqldumpslow -s 的更多参数<ul><li>c 访问计数</li><li>i 锁定时间</li><li>r 返回记录</li><li>t 查询时间</li><li>al 平均锁定时间</li><li>ar 平均返回记录数</li><li>at 平均查询时间</li></ul></li></ul><pre><code>使用：    1. 得到返回记录集最多的 10 个 SQL        mysqldumpslow -s r -t 10 slow.log    2. 得到访问次数最多最多的 10 个 SQL        mysqldumpslow -s c -t 10 slow.log    3. 得到按照时间排序的前 10 条里面含有左连接的查询语句        mysqldumpslow -s t -t 10 -g &quot;left join&quot; slow.log</code></pre><ul><li>SQL 语句性能分析<ul><li>explain select 语句</li></ul></li></ul><pre><code class="markdown">explain 返回结果分析    1. ID： select 识别符，代表语句的执行顺序，id 数字越大越先执行，如果一样大，从上往下执行    2. select_type:     3. table: 显示查询表名，&lt;derived N&gt; 临时表    **4. type: **        1) 依次从好到差：**system, const, eq_ref,** ref, fulltext, ref_or_null, unique_subquery, index_subquery, range, **index_merge, index, all**        2) 除了 all, 其他 type 都可以使用到索引，除了 index_merge（表示查询使用两个以上的索引）, 其他 type 只可以用到一个索引    5. possible_keys: 可能使用的索引    6. key: 真正使用到的索引    7. key_len:     8. ref:    9. rows: 估算的扫描行数    10. extra:</code></pre><h3 id="MySQL-索引的概念及作用"><a href="#MySQL-索引的概念及作用" class="headerlink" title="MySQL 索引的概念及作用"></a>MySQL 索引的概念及作用</h3><p>[ 索引类型 ]</p><ul><li>主键索引（唯一索引，不允许有空值）</li><li>全文索引（fulltext, MyISAM 表特有）</li><li>唯一索引（值唯一，允许有空值）</li><li>组合索引（多列索引，多列同时创建索引）</li><li>普通索引（无限制）</li></ul><p>[ 索引创建规则 ]</p><ul><li>可以提高查询速度，但是减低插入和更新的速度，并占用磁盘空间</li><li>在插入与更新数据时，要重写索引文件</li><li>单张表索引数量最好不超过 5 个</li><li>单个索引中的字段数不超过 5 个（组合索引）</li><li>不适用索引的查询： like 模糊查询；反向查询，not in / not like</li></ul><h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><ul><li>MyISAM（只支持表锁）</li></ul><pre><code>优点：    1. 读取性能比 innoDB 高    2. 索引与数据分离，使用压缩，从而提高了内存使用率缺点：    1. 不支持事务    2. 写入数据时，直接锁表（表锁）</code></pre><ul><li>InnoDB</li></ul><pre><code>优点：    1. 支持事务     2. 支持外键    3. 支持行锁缺点：    1. 不支持 全文索引    2. 行锁并不绝对，当不确定扫描范围时，锁全表    3. 索引与数据捆绑，没有使用压缩，导致体积庞大</code></pre><h3 id="MySQL-实时监控"><a href="#MySQL-实时监控" class="headerlink" title="MySQL 实时监控"></a>MySQL 实时监控</h3><ul><li>orzdba(监控工具)</li></ul><pre><code>./orzdba 执行使用：</code></pre><h3 id="MySQL-集群监控方案-天兔-LEPUS"><a href="#MySQL-集群监控方案-天兔-LEPUS" class="headerlink" title="MySQL 集群监控方案 - 天兔 LEPUS"></a>MySQL 集群监控方案 - 天兔 LEPUS</h3><ul><li>天兔 LEPUS 全部数据库实例监控</li></ul><pre><code>本地部署： 产品 &gt; 文档中心 &gt; 安装    admin /Lepusadmin</code></pre><h3 id="MySQL-性能测试的用例准备"><a href="#MySQL-性能测试的用例准备" class="headerlink" title="MySQL 性能测试的用例准备"></a>MySQL 性能测试的用例准备</h3><pre><code>要点：使用 sql 模拟用户使用场景(增删改查语句)工具：JMeter步骤：     1. JDBC Connection Configuration 配置 MySQL        Database URL:  jdbc:mysql://192.168.1.7:3306/test        Driver class:  com.mysql.cj.jdbc.Driver        Username:        Password:    2. JDBC Request 写 SQL 脚本        select * fom user</code></pre>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
      <category>性能测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>性能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Robot Framework</title>
    <link href="/alwaysblog/post/3888393026/"/>
    <url>/alwaysblog/post/3888393026/</url>
    
    <content type="html"><![CDATA[<p><strong>特点</strong></p><ul><li>提供可视化界面 ride、 eclipse</li><li>txt、html 等格式编写测试用例，而不是编程语言</li><li>支持<strong>关键字驱动</strong>（直接调用已有的关键字，组成自动化用例）</li><li>支持 web 、app、api 自动化测试</li><li>开源，基于 Python 编写</li></ul><h2 id="Robot-Framework-环境搭建"><a href="#Robot-Framework-环境搭建" class="headerlink" title="Robot Framework 环境搭建"></a>Robot Framework 环境搭建</h2><ul><li><strong>安装 wxPython</strong></li></ul><pre><code class="shell">$ 下载页面： http://wxpython.org/download.php#stable    在选择版本下载的时候要注意选择与 Python 版本对应的版本，并且选择 unicode 版本。    比如版本：wxPython2.8-win64-unicode-py27.exe，否则安装完成后不能支持中文。    下载完成后，选择默认项进行安装即可。</code></pre><ul><li><strong>安装 Robot Framwork</strong></li></ul><pre><code class="shell">$    pip install robotframwork    图形化界面：RIDE        pip install robotframework-ride        pip install robotframework-ride==1.7.4.1（指定版本安装）</code></pre><ul><li><strong>安装 selenium2library</strong></li></ul><pre><code class="shell">$    pip install robotframework-selenium2library</code></pre><ul><li><strong>第三方包本地安装</strong></li></ul><pre><code class="shell">$  **.whl : $        pip install  **.whl$  **.egg : $        1. 先下载ez_setup.py,运行python ez_setup 进行easy_install工具的安装$        2. easy_install **.egg$  **.zip / tar.gz$        python setup.py install</code></pre><ul><li><p><strong>启动 RIDE</strong></p><ul><li><p>通过文件启动（双击 [dirPath]\python\Lib\site-packages\robotide下的<strong>init</strong>.py文件）</p></li><li><p>通过命令启动（运行 -&gt; ride.py 回车 / 确认）</p><pre><code class="shell">$    cd C:\Python27\Scripts\# 运行$ python ride.py</code></pre></li><li><p>将C:\Python27\Scripts\ride.py 创建快捷键，打开 ride.py 文件之后（以 python 方式打开），点击“运行（start）”按钮。</p></li></ul></li><li><p><strong>查看 pybot 版本</strong></p></li></ul><pre><code class="shell">$    cd C:\Python27\Scripts# 运行$ pybot --version</code></pre><h2 id="Robot-Framework-PyCharm"><a href="#Robot-Framework-PyCharm" class="headerlink" title="Robot Framework + PyCharm"></a>Robot Framework + PyCharm</h2><ul><li><strong>pyCharm 插件</strong></li></ul><pre><code class="shell">$    File &gt;&gt; Settings &gt;&gt; Plugins &gt;&gt; intelliBot 插件 install</code></pre><ul><li><strong>RobotFramework 的文件类型识别配置</strong></li></ul><pre><code class="shell">$    File &gt;&gt; Settings &gt;&gt; Editor &gt;&gt; File Types$        列表中 找到 Robot Feature 选中$        File Name Patterns: 点击 +  &gt;&gt; 分别添加 *.txt 和 *.</code></pre><ul><li><strong>Suite 和 Case 的执行配置</strong></li></ul><pre><code class="shell">$    在我们在执行脚本时，可以单独执行一个case，也可以执行case的集合：suite（测试套），所以我们这里要做两个配置。$     File &gt;&gt; Settings &gt;&gt; Tools &gt;&gt; External Tools &gt;&gt; 点击 +$         Name：Robot Run SingleTestCase$        Program: C:\Python\Python27\Scripts\robot.exe$       Arguments：-d results -t &quot;$SelectedText$&quot; ./$       Working directory：$FileDir$$    点击 + $       Name：Robot Run TestSuite$        Program: C:\Python\Python27\Scripts\robot.exe$       Arguments：-d results $FileName$$       Working directory：$FileDir$</code></pre><ul><li><strong>问题解决</strong></li></ul><pre><code class="shell">解决：‘chromedriver’ executable needs to be in PATH 问题 （在使用 selenium 启动谷歌 Chrome 浏览器的时候，是需要用到 chromedirver 的）    1.首先需要下载 Chromedriver，下载后得到的是一个 chromedriver.exe 文件。        chromedriver下载地址:  http://npm.taobao.org/mirrors/chromedriver/    2.将 chromedriver.exe 拷贝至谷歌浏览器目录（如 C:\Program Files\Google\Chrome\Application）以及 python 根目录（C:\Python27）。    3.将谷歌浏览器环境变量添加到path（C:\Users\HD003\AppData\Local\Google\Chrome\Application）。    至此，就可以解决 ‘chromedriver’ executable needs to be in PATH问题了。</code></pre><h2 id="Robot-Framework-Eclipse"><a href="#Robot-Framework-Eclipse" class="headerlink" title="Robot Framework + Eclipse"></a>Robot Framework + Eclipse</h2><h2 id="Robot-Framework-RIDE"><a href="#Robot-Framework-RIDE" class="headerlink" title="Robot Framework + RIDE"></a>Robot Framework + RIDE</h2><h3 id="RIDE-的使用"><a href="#RIDE-的使用" class="headerlink" title="RIDE 的使用"></a>RIDE 的使用</h3><pre><code class="shell">工程创建：     File =&gt; New Project            =&gt; Type: Directory(方便管理) 如果内容简单选择 file            =&gt; Format: 推荐 txt          =&gt; New Suite(测试套件)             =&gt; Type: file             =&gt; Format: txt         =&gt; New Test Case    注意： *测试套件，表示它有了新的修改，还没有保存Project 工作区：第一行的 Source 列出了这个 Project 的路径  Settings:    Documentation：文档，每一项都有。可以给当前的对象加入文档说明。    Setup 和 TearDown 分别表示启动和停止，也就是你可以在对应的文本框设置一个关键字，那么指定的事件触发的时候就会执行这个关键字。    Suite Stetup: 套件启动    Suite Teardown: 套件停止    Test Steup: 案例启动    Test Teardown: 案例停止    Force Tags: 强制 tag 标记，强制的给他的所有子元素加上这些tags。后面运行的时候我们可以选择指定tag的案例来运行。资源添加：    右键 工程名称 =&gt; New Resource    或    右键 External Resources =&gt; Add Resource    用户关键字：（Resource 用来保存用户关键字）    右键新创建的资源 =&gt; New User Keyword User Keyword 工作区：    Tags：     Documentation：文档，每一项都有。可以给当前的对象加入文档说明。$$  Arguments: 设置传入参数    Teardown: 设置完成时的动作，比如写上 Close All Browsers，表示在这个用户关键字执行完成之后会执行什么关键字。    Timeout: 设置超时时间，如写上 1min，表示 1 分钟超时，如果这个关键字执行超过 1 分钟则认为失败。$$  Return Value: 设置返回值        User Keywords 其实就是一个函数,Bulletin 的 Keywords 和 TestLib 里的 Keywords 也都是一个个的函数，只是封装在不同层面。后 2 个是在代码级的封装，将 python 代码写成的函数封装成可以调用的关键字，而User Keywords 就是把这些可调用的关键字进一步的封装，可以理解为应用层面的封装，而且可以层层封装。到后面你会发现，大部分时间，你其实是和User Keywords在打交道，利用好User Keywords，会方便很多。</code></pre><h5 id="测试套件（TestSuite）"><a href="#测试套件（TestSuite）" class="headerlink" title="测试套件（TestSuite）"></a>测试套件（TestSuite）</h5><pre><code>测试套件工作区：第一行的 Source 列出了这个 TestSuite 的路径Settings:    Documentation：    Suite Stetup:    Suite Teardown:     Test Steup:     Test Teardown:    Test Template：测试模版，可以指定某个关键字为这个测试套件下所有 TestCase 的模版，这样所有的 TestCase 就只需要设置这个关键字的传入参数即可    Test Timeout：    Force Tags: 在文件型 Suite 这里还可以继续给子元素增加 Force Tags，但是他不能删除父元素设置的 tags    Default Tags：默认标记，其实和 Force Tags 没啥区别的，效果都是一样的，只是颜色不同而已。        再往下大体分为三部分（1）加载外部文件    Add Library ：加载测试库，主要是[PYTHON目录]\Lib\site-packages里的测试库    Add Resource：加载资源，主要是你工程相关的资源文件    Add Variables：加载变量文件（2）定义内部变量    Add Scalar：定义变量    Add List：定义列表型变量    Add Dict：定义字典型变量（3）元数据定义    Add Metadata：定义元数据。作用是在 report 和 log 里显示定义好的内容，格式和 document 一样。</code></pre><h5 id="测试用例（TestCase）"><a href="#测试用例（TestCase）" class="headerlink" title="测试用例（TestCase）"></a>测试用例（TestCase）</h5><pre><code class="shell">测试用例工作区：Settings:    Documentation：略    Stetup: 略    Teardown: 略    Template：略    Timeout：略</code></pre><h5 id="Run-页面"><a href="#Run-页面" class="headerlink" title="Run 页面"></a>Run 页面</h5>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
      <category>自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>自动化测试，Robot Framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试用例设计</title>
    <link href="/alwaysblog/post/3157456672/"/>
    <url>/alwaysblog/post/3157456672/</url>
    
    <content type="html"><![CDATA[<h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><h3 id="qq⽂件传输测试⽤例"><a href="#qq⽂件传输测试⽤例" class="headerlink" title="qq⽂件传输测试⽤例"></a>qq⽂件传输测试⽤例</h3><ul><li>传输成功</li></ul><ol><li>⽂件直接拖到对话框，点击发送</li><li>点击传送⽂件按钮，选择⽂件，点击发送</li><li>传送汇总显示进度条</li><li>传送显示⽂件名字，以及⽂件⼤⼩</li><li>给⼀个⽤户传输多个⽂件</li><li>同时给不同⽤户传输⽂件（相同⽂件和不同⽂件)</li><li>本地打开的时候，可以传送⽂件</li><li>接收成功的默认路径</li><li>⽂件接收后，是否正常</li><li>是否可以更改保存路径</li><li>⽂件传输时，不影响其他功能</li><li>接收⽅在线，不在线，离线⽂件，好友，⾮好友（临时会话）</li></ol><ul><li>传输失败</li></ul><ol><li>点击取消，可以取消⽂件发送</li><li>接收⽅，拒绝接收</li><li>直接关闭对话框，有提示，有⽂件在传输</li><li>⽂件-⽂件夹，⽂件夹多层，空⽂件</li><li>⽂件⼤⼩的边界值</li></ol><ul><li>⽂件名称</li></ul><ol><li>普通⽂件</li><li>含有特殊符号的⽂件</li><li>⽂件名空，空格，纯中⽂，中英混合，纯英⽂，含有标点符号</li></ol><ul><li>⽂件格式</li></ul><ol><li>exe⽂件，txt，doc，pdf等</li><li>图⽚、视频、⾳频、压缩⽂件、⽂件夹、病毒⽂件</li></ol><ul><li>界⾯测试</li></ul><ol><li>界⾯美观、易⽤</li><li>按钮位置符合规范以及正确</li><li>提示语是否正确</li></ol><ul><li>其他测试</li></ul><ol><li>弱⽹情况传输</li><li>上传中断⽹</li><li>上传⽂件，把源⽂件删除</li></ol><h3 id="一个有广告的纸杯子，请设计测试用例？"><a href="#一个有广告的纸杯子，请设计测试用例？" class="headerlink" title="一个有广告的纸杯子，请设计测试用例？"></a>一个有广告的纸杯子，请设计测试用例？</h3><ul><li>测试项目：杯子</li><li>需求测试：查看杯子使用说明书</li><li>界面测试：查看杯子外观</li><li>功能度：用水杯装水看漏不漏；水能不能被喝到</li><li>安全性：杯子有没有毒或细菌</li><li>可靠性：杯子从不同高度落下的损坏程度</li><li>可移植性：杯子再不同的地方、温度等环境下是否都可以正常使用</li><li>兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等</li><li>易用性：杯子是否烫手、是否有防滑措施、是否方便饮用</li><li>用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述</li><li>疲劳测试：将杯子盛上水（案例一）放 24 小时检查泄漏时间和情况；盛上汽油（案例二）放 24 小时检查泄漏时间和情况等</li><li>压力测试：用根针并在针上面不断加重量，看压强多大时会穿透</li><li>跌落测试: 杯子加包装(有填充物),在多高的情况摔下不破损</li><li>震动测试: 杯子加包装(有填充物),六面震动,检查产品是否能应对恶劣的铁路\公路\航空运输</li><li>硬度：是否达到设计标准。<ul><li>装载能力：在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。</li><li>装载种类：开水（是否产生异味）、温水、冷水、冰水、咖啡。。。</li></ul></li><li>界面测试（UI 测试）。<ul><li>看其形状、大小设计是否适合人方便拿起。</li><li>外观是否吸引人（广告嘛），赏心悦目。 </li><li>带广告的图案沾水受是否掉色、模糊。</li></ul></li><li>易用性测试。<ul><li>看其形状、大小设计是否适合人方便拿起。</li><li>残疾人士用此杯去喝水的容程度。</li><li>杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。</li></ul></li><li>稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。</li><li>安全性测试。杯子所用的材料（包括纸基、涂层和广告颜料）是否符合食品卫生标准，在内外温度等环境因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。</li><li>本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。</li><li>对设计的改进建议。“如果是一次性杯子，能否标示已使用（比如变色）”和“杯子是否有使用者标贴（多人使用时防止混淆）”。</li></ul><h3 id="一个身份证号码输入框，怎么设计用例？"><a href="#一个身份证号码输入框，怎么设计用例？" class="headerlink" title="一个身份证号码输入框，怎么设计用例？"></a>一个身份证号码输入框，怎么设计用例？</h3><ul><li>校验身份证号规则的有效性（包括地址码、生日期码、顺序码和校验码</li><li>校验 15 位身份证号和 18 位身份正好都是可用的</li><li>校验末位是 X 的情况</li><li>校验不足 15 位、16-17 位和大于 18 位的情况</li><li>如果是必输项，校验不输入的时候会不会有正确的提示</li><li>如果不是必输项，则要校验不输入的时候流程能否正常进行</li><li>校验输入非数字的情况，是否会有正确提示信息（包括大小写字母、汉字、特殊字符和标点符号）</li><li>校验输入全角的数字的时候，系统是否会识别（这个得根据需求确定是否可以使用全角的数字）</li></ul><h3 id="登录功能怎么设计测试用例？"><a href="#登录功能怎么设计测试用例？" class="headerlink" title="登录功能怎么设计测试用例？"></a>登录功能怎么设计测试用例？</h3><p>具体需求：<br>有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。</p><p><strong>[ 考察目的：]</strong></p><ol><li>了解需求（测什么都是从了解需求开始）；</li><li>是否有设计 Test Case 的能力</li><li>是否熟悉各种测试方法；</li><li>是否有丰富的 Web 测试经验；</li><li>是否了解 Web 开发；</li></ol><p><strong>[ 了解需求：]</strong></p><p>1、登录界面应该是弹出窗口式的，还是直接在网页里面；<br>2、账号长度和密码的强度（比如需要多少位、大小写敏感、特殊字符混搭等）；<br>3、界面美观是否有特殊要求？（即是否要进行 UI 测试）；<br>4、····</p><p><strong>[ 用例设计：]</strong></p><ul><li>功能测试<ul><li>输入正确的账号和密码，点击提交按钮，验证是否能正确登录。（正常输入）</li><li>输入错误的账号或者密码, 验证登录会失败，并且提示相应的错误信息。（错误校验）</li><li>登录成功后能否跳转到正确的页面（低）</li><li>账号和密码，如果太短或者太长，应该怎么处理（安全性，密码太短时是否有提示）</li><li>账号和密码，中有特殊字符（比如空格），和其他非英文的情况（是否做了过滤）</li><li>记住账号的功能</li><li>登录失败后，不能记录密码的功能</li><li>账号和密码前后有空格的处理</li><li>密码是否加密显示（星号圆点等）</li><li>牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用</li><li>登录页面中的注册、忘记密码，登出用另一帐号登录等链接是否正确</li><li>输入密码的时候，大写键盘开启的时候要有提示信息。</li><li>什么都不输入，点击提交按钮，看提示信息。（非空检查）</li></ul></li><li>界面测试<ul><li>布局是否合理，2 个 Testbox 和一个按钮是否对齐</li><li>Testbox 和按钮的长度，高度是否复合要求</li><li>界面的设计风格是否与 UI 的设计风格统一</li><li>界面中的文字简洁易懂，没有错别字。</li></ul></li><li>性能测试(Performance Test)<ul><li>打开登录页面，需要几秒</li><li>输入正确的账号和密码后，登录成功跳转到新页面，不超过 5 秒</li></ul></li><li>安全性测试(Security Test)<ul><li>登录成功后生成的 Cookie 是否有 HttpOnly(降低脚本盗取风险)</li><li>账号和密码是否通过加密的方式，发送给 Web 服务器</li><li>账号和密码的验证，应该是用服务器端验证，而不能单单是在客户端用 javaScript 验证</li><li>账号和密码的输入框，应该屏蔽 SQL 注入攻击</li><li>账号和密码的的输入框，应该禁止输入脚本（防止 XSS 攻击）</li><li>错误登录的次数限制（防止暴力破解）</li><li>考虑是否支持多用户在同一机器上登录；</li><li>考虑一用户在多台机器上登录</li></ul></li><li>可用性测试(Usability Test)<ul><li>是否可以全用键盘操作，是否有快捷键</li><li>输入账号，密码后按回车，是否可以登录</li><li>输入框是否可以以 Tab 键切换</li></ul></li><li>兼容性测试（Compatibility Test）<ul><li>主流的浏览器下能否显示正常已经功能正常（IE6~11, FireFox, Chrome, Safari 等 ）</li><li>不同的平台是否能正常工作，比如 Windows, Mac</li><li>移动设备上是否正常工作，比如 iPhone, Android</li><li>不同的分辨率</li></ul></li></ul><h3 id="假如有一个预约口罩的功能"><a href="#假如有一个预约口罩的功能" class="headerlink" title="假如有一个预约口罩的功能"></a>假如有一个预约口罩的功能</h3><ul><li>每天只能预约一次；</li><li>每天晚上 8 点公布前一天的预约结果；</li><li>每次预约时需要提交一个表单，表格里包括身手机号，身份证号等信息。你针对这个来说一说有哪些测试点。越多越好</li></ul><p> <strong>预约次数，是否准时公布结果，公布结果是否正确，表单是否必填，手机号长度、号段、特殊字符，身份证长度，末尾最后一项，提交按钮是否正常响应，预约信息是否添加数据库，预约人数限制，预约地区限制，预约条件、身份认证</strong></p><ol start="2"><li>比如你一个 OA 系统里面功能比较多，你是通过手工快速去点还是用什么方式去快速完成这个测试工作？</li></ol><ul><li>如果是新功能开发的测试阶段，肯定是需要点点点</li><li>如果是老功能做回归测试，则需要做自动化测试</li></ul><ol start="3"><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>测试用例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 命令总结</title>
    <link href="/alwaysblog/post/1564283385/"/>
    <url>/alwaysblog/post/1564283385/</url>
    
    <content type="html"><![CDATA[<p><strong>[ 命令格式 ]</strong></p><ul><li>命令 [ 选项 ][ 参数 ]</li><li>例： ls -la /home</li></ul><h3 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h3><ul><li><p>ls</p><ul><li>原意： list</li><li>功能： 显示目录文件</li><li>选项： -a： 显示所有文件(all)，-l： 显示详细信息(long)</li><li>参数： 路径（非必填）</li><li>语法： ls -la /home</li></ul></li><li><p>cd</p><ul><li>原意： change directory</li><li>功能： 切换目录</li><li>参数： 路径</li><li>语法： cd /home (绝对路径) 或者 cd admin (相对路径)</li></ul></li><li><p>pwd</p><ul><li>原意： print working directory</li><li>功能： 显示当前目录</li><li>语法： pwd</li></ul></li><li><p>mkdir</p><ul><li>原意： make directories</li><li>功能： 创建空目录</li><li>选项： -p： 递归创建(可以创建不存在的目录，如： /home/admin/document/work)</li><li>参数： 目录名</li><li>语法： mkdir -p [目录名]</li></ul></li><li><p>cp</p><ul><li>原意： copy</li><li>功能： 复制文件或目录</li><li>选项： -r： 复制目录，-p： 保留文件属性 copy(保留创建时间等)</li><li>参数： [原文件或目录][目标目录]</li><li>语法： cp -rp [原文件或目录][目标目录]</li></ul></li><li><p>mv</p><ul><li>原意： move</li><li>功能： 剪切文件或者改文件名</li><li>参数： [原文件或目录][目标目录] 或者 [原文件名][修改文件名]</li><li>语法： mv [原文件或目录][目标目录]</li></ul></li><li><p>rm</p><ul><li>原意： remove</li><li>功能： 删除文件或目录</li><li>选项： -r： 删除目录，-f： 强制删除</li><li>参数： 文件或目录</li><li>语法： rm -rf [文件或目录] ==&gt; 强制删除</li></ul></li><li><p>rmdir</p><ul><li>原意： remove empty directories</li><li>功能： 删除空目录</li><li>语法： rmdir [空目录]</li></ul></li></ul><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><ul><li><p>touch</p><ul><li>功能： 创建空文件</li><li>语法： touch [文件名]</li></ul></li><li><p>cat</p><ul><li>功能： 显示文件内容</li><li>选项： -n 显示行号</li><li>语法： cat [文件名]</li></ul></li><li><p>tac</p><ul><li>功能： 反向显示文件内容</li><li>选项： -n 显示行号</li><li>语法： tac [文件名]</li></ul></li><li><p>more</p><ul><li>功能： 分页显示文件内容</li><li>语法： more [文件名]</li><li>操作： 空格 =&gt; 换页; Enter =&gt; 换行; Q =&gt; 退出; （B =&gt; 上翻）</li></ul></li><li><p>ln</p><ul><li>原意： link</li><li>功能： 创建软链接(快捷方式)或硬链接(复制文件，文件内容动态变化)</li><li>选项： -s： 创建软链接</li><li>语法： ln -s [原文件或目录][目标文件或目录] ==&gt; 软链接; ln [原文件或目录][目标文件或目录] ==&gt; 硬链接;</li></ul></li><li><p>less</p><ul><li>功能： 分页显示文件内容</li><li>语法： less [文件名]</li><li>操作： 空格 =&gt; 换页; Enter =&gt; 换行; Q =&gt; 退出; B =&gt; 向上翻页</li></ul></li><li><p>head</p><ul><li>功能： 显示文件前面几行</li><li>选项： -n： 指定行数</li><li>语法： head -n 10 [文件名]</li></ul></li><li><p>tail</p><ul><li>功能： 显示文件后面几行</li><li>选项： -n： 指定行数; -f： 动态显示文件末尾的内容</li><li>语法： tail -n 10 [文件名]</li></ul></li></ul><h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><ul><li><p>find</p><ul><li>功能： 文件搜索</li><li>语法： find [搜素范围][匹配条件] [搜素内容]</li><li>例： find /home -name log.md (搜素 log.md 文件)<blockquote><p>[ 匹配条件 ]</p><ul><li>name： 名称搜素</li><li>size： 文件大小搜素(按块搜素，1 块 = 0.5k，00M = 204800 块)</li></ul><ul><li>+n(+204800) 大于 204800</li><li>-n</li><li>n 等于</li></ul><ul><li>type： 文件类型</li></ul></blockquote></li></ul></li><li><p>grep</p><ul><li>功能： 在文件中搜索字符串匹配的行并输出</li><li>选项： -i 不区分大小写; -v 排除指定字符串</li><li>语法： grep -iv [指定字符串][文件]</li></ul></li><li><p>locate</p><ul><li>功能： 在文件资料库中查找文件</li><li>语法： locate [文件名]</li></ul></li><li><p>which</p><ul><li>功能： 搜索命令所在目录及别名信息</li><li>语法： which [命令]</li></ul></li><li><p>whereis</p><ul><li>功能： 搜索命令所在目录以及帮助文档路径</li><li>语法： whereis [命令]</li></ul></li></ul><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><ul><li>man<ul><li>功能： 获取帮助信息</li><li>语法： man [命令或帮助文件]</li></ul></li><li>help<ul><li>功能： 获取 shell 内置命令的帮助信息</li><li>语法： help [内置命令]</li></ul></li></ul><h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><ul><li>chmod<ul><li>原意： change mode</li><li>功能： 改变文件或目录的权限</li><li>语法： chmod [ugoa+-=rwx][文件或目录]</li><li>例： chmod u-r [文件或目录] =&gt; 对文件的所属者去掉 r 权限</li><li>语法： chmod [mode = 777][文件或目录] =&gt; 给文件设置所有的用户拥有全部的权限</li><li>例： chmod 764 [文件或目录]</li><li>执行权限： 所有用户</li></ul></li></ul><blockquote><p><strong>[ u，g，o，a 分别代表用户 ]</strong></p><ul><li>u： User 所属者</li><li>g： Group 用户组</li><li>o： Other 其他用户</li><li>a： all 所有人</li></ul><p><strong>[ r，w，x 分别代表权限 ]</strong></p><ul><li>r： read 读权限<ul><li>用数字表示 4</li></ul></li><li>w： write 写权限<ul><li>用数字表示 2</li></ul></li><li>x： 执行权限<ul><li>用数字表示 1</li></ul></li><li>每一个文件或目录都会用 rwxrwxrwx 来显示 ugo 三者的权限(顺序不可变)</li><li>例： rwxrw-r– 指的是 u 拥有所有的权限，g 拥有读写的权限，o 只拥有&gt;读的权限<ul><li>用数字表示： 764（4+2+1，4+2，4）</li></ul></li></ul></blockquote><ul><li>chown<ul><li>原意： change file ownership</li><li>功能： 改变文件或目录的所属者</li><li>语法： chown [用户][文件/目录]</li><li>执行权限： root</li></ul></li><li>umask<ul><li>命令英文原意： the user file-creation mask</li><li>显示、设置文件的缺省权限(默认权限)</li><li>执行权限： 所有用户</li><li>语法： umask [-S] -S 以 rwx 形式显示新建文件的缺省权限</li></ul></li></ul><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><ul><li>useradd<ul><li>功能： 添加新用户</li><li>执行权限： root</li></ul></li><li>passwd<ul><li>功能： 修改密码</li></ul></li><li>who<ul><li>功能： 查看登录用户信息</li></ul></li><li>w<ul><li>功能： 当前用户详细信息</li></ul></li></ul><h3 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h3><ul><li>tar<ul><li>功能： 打包文件或目录</li><li>说明： <strong>结合 gzip 命令</strong></li><li>语法： tar -zcf 新的文件名.tar.gz [目标文件或目录] ==&gt;直接打包压缩</li><li>解压： tar -zxf 文件名.tar.gz</li></ul></li><li>zip<ul><li>功能： 压缩文件或目录</li><li>选项： -r 压缩目录</li><li>语法： zip [新的文件名][目标文件或目录]</li><li>解压： unzip [压缩文件名.zip]</li></ul></li><li>bzip2<ul><li>功能： 打包文件()</li><li>选项： -k 保留原文件</li><li>说明： <strong>结合 tar 命令使用</strong></li><li>语法： tar -cjf 新的文件名.tar.bz2 [目标文件或目录] ==&gt;直接打包压缩</li><li>解压： tar -xjf 文件名.tar.bz2</li></ul></li></ul><h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><ul><li>ping<ul><li>功能： 测试网络连通性</li><li>语法： ping [ip 地址]</li></ul></li><li>last<ul><li>功能： 列出目前和过去登入系统的用户信息</li><li>语法： last</li></ul></li><li>traceroute<ul><li>功能： 显示数据包到主机间的路径</li><li>语法： traceroute [ip 地址 或 域名]</li></ul></li><li>netstat<ul><li>功能： 显示网络相关信息</li><li>语法： netstat</li></ul></li><li>steup<ul><li>功能： 配置网络</li><li>语法： steup</li></ul></li><li>write<ul><li>功能： 给用户发信息</li><li>语法： write [用户名]</li></ul></li><li>wall<ul><li>功能： 发广播信息</li><li>语法： wall</li></ul></li><li>mail<ul><li>功能： 发送电子邮件</li><li>语法： mail [用户名]</li></ul></li></ul><h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3><ul><li>shutdown [选项] now(时间)<ul><li>-c 取消</li><li>-h 关机</li><li>-r 重启</li></ul></li><li>其他关机<ul><li>halt</li><li>poweroff</li><li>init 0</li></ul></li><li>其他重启<ul><li>reboot</li><li>init 6</li></ul></li><li>扩展</li></ul><ul><li>0 –&gt; 关机</li><li>1 –&gt; 单用户</li><li>2 –&gt; 不完全多用户，不含 nfs 服务</li><li>3 –&gt; 完全多用户</li><li>4 –&gt; 未分配</li><li>5 –&gt; 图形界面</li><li>6 –&gt; 重启</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>linux 命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/alwaysblog/post/4065722285/"/>
    <url>/alwaysblog/post/4065722285/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><ol><li>通过 uname -r 命令查看你当前的内核版本<pre><code class="shell">$ uname -r</code></pre></li></ol><ol start="2"><li><p>root权限更新Yum包</p><pre><code class="shell">$ yum update</code></pre></li><li><p>卸载旧版本：（如果安装过旧版本的话）<br>(旧版名称是docker , 最新社区版 docker-engine， 目前已改名为docker-ce )</p><pre><code class="shell">$ yum -y remove docker docker-common docker-selinux docker-engine</code></pre></li><li><p>设置Yum源：（本文以Yum安装为例子进行安装）</p></li></ol><ul><li><p>安装 yum-utils , 使用 yum-config-manager 工具设置Yum源, 后面两个是 devicemapper驱动依赖</p><pre><code class="shell">$ yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre></li><li><p>执行以下命令，添加docker的yum源</p><pre><code class="shell"> $ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 此处可能会报错 （原因是国内访问不到docker官方镜像的缘故） Loaded plugins: fastestmirror（镜像） adding repo from: https://download.docker.com/linux/centos/docker-ce.repo grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo Could not fetch/save url https://download.docker.com/linux/centos/docker-ce.repo to file /etc/yum.repos.d/docker-ce.repo:  [Errno 14] curl#35 - &quot;TCP connection reset by peer # 解决方法 ： 使用阿里源访问$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre></li></ul><ol start="5"><li><p>查看所有仓库中docker版本，并选择特定版本安装：(此处我们查看社区版 docker-ce)</p><pre><code class="shell">$ yum list docker-ce --showduplicates | sort -r</code></pre></li><li><p>配置镜像加速器（必须要配置，否则会出现访问镜像并不稳定 ，而且下载缓慢等问题）</p></li></ol><ul><li>注册阿里云账号 ，登陆该网址自行注册 ( <a href="https://www.aliyun.com/?utm_content=se_1010377" rel="external nofollow noreferrer">https://www.aliyun.com/?utm_content=se_1010377</a> )</li><li>进入阿里云控制台如图 ( <a href="https://cr.console.aliyun.com/#/accelerator" rel="external nofollow noreferrer">https://cr.console.aliyun.com/#/accelerator</a> )</li><li>执行命令 :<pre><code class="shell">$ mkdir -p /etc/docker$ tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&gt; &#123; &gt;    &quot;registry-mirrors&quot;: [&quot;输入你自己控制台此处的地址&quot;]&gt; &#125;EOF$  systemctl daemon-reload    （导入操作）</code></pre></li></ul><ol start="7"><li><p>安装docker (此处我们安装社区版 docker-ce)</p><pre><code class="shell">$ yum install docker-ce (这样写默认安装最新版本)$ yum install  docker-ce-&lt;VERSION_STRING&gt; (指定安装版本) #例： yum install docker-ce-18.03.1.ce</code></pre></li><li><p>启动并加入开机启动</p><pre><code class="shell">$ systemctl start docker       (重启命令  $  systemctl restart docker ) $ systemctl enable docker   开机启动$ docker version  查看docker版本号</code></pre></li><li><p>验证是否安装成功</p><pre><code class="shell">$ docker run hello-world</code></pre><h2 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h2></li></ol><ul><li><p>查看所有运行或者不运行容器</p></li><li><p>列出所有容器ID</p></li><li><p>停止所有的container（容器），这样才能够删除其中的images：</p></li><li><p>如果想要删除所有container（容器）的话再加一个指令：</p></li><li><p>查看当前有些什么images</p></li><li><p>删除images（镜像），通过image的id来指定删除谁</p><pre><code class="shell">docker psdocker ps -adocker ps -aqdocker imagesdocker exec -it [name / id] /bin/bashexit()</code></pre></li></ul><h2 id="Docker-开机配置"><a href="#Docker-开机配置" class="headerlink" title="Docker 开机配置"></a>Docker 开机配置</h2><ul><li><p>docker 中启动所有的容器命令</p><pre><code class="shell">    docker start $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre></li><li><p>docker 中关闭所有的容器命令</p><pre><code class="shell">    docker stop $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre></li><li><p>docker 中删除所有的容器命令</p><pre><code class="shell">    docker rm $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre></li><li><p>docker 中删除所有的镜像</p><pre><code class="shell">    docker rmi $(docker images | awk &#39;&#123;print $3&#125;&#39; |tail -n +2)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>前沿技术</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 刷题记录</title>
    <link href="/alwaysblog/post/2689587330/"/>
    <url>/alwaysblog/post/2689587330/</url>
    
    <content type="html"><![CDATA[<h2 id="组合两个表"><a href="#组合两个表" class="headerlink" title="组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/" rel="external nofollow noreferrer">组合两个表</a></h2><p>表1: Person</p><pre><code>+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+PersonId 是上表主键</code></pre><p>表2: Address</p><pre><code>+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+AddressId 是上表主键</code></pre><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><pre><code>FirstName, LastName, City, State</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql">select FirstName, LastName, City, State from Personleft join Address on Address.PersonId = Person.PersonId;-- left join Address using(PersonId)</code></pre><h2 id="第二高的薪水"><a href="#第二高的薪水" class="headerlink" title=" 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/" rel="external nofollow noreferrer"> 第二高的薪水</a></h2><p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p><pre><code>+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+</code></pre><p>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p><pre><code>+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"># Write your MySQL query statement below# 方法一select MAX(Salary) as SecondHighestSalary from Employee WHERE Salary &lt; (select max(Salary) from Employee)；# 方法二-- SELECT--     IFNULL(--       (SELECT DISTINCT Salary--        FROM Employee--        ORDER BY Salary DESC--         LIMIT 1 OFFSET 1),--     NULL) AS SecondHighestSalary；</code></pre><h2 id="超过经理收入的员工"><a href="#超过经理收入的员工" class="headerlink" title="超过经理收入的员工"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/" rel="external nofollow noreferrer">超过经理收入的员工</a></h2><p>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><pre><code>+----+-------+--------+-----------+| Id | Name  | Salary | ManagerId |+----+-------+--------+-----------+| 1  | Joe   | 70000  | 3         || 2  | Henry | 80000  | 4         || 3  | Sam   | 60000  | NULL      || 4  | Max   | 90000  | NULL      |+----+-------+--------+-----------+</code></pre><p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><pre><code>+----------+| Employee |+----------+| Joe      |+----------+</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"># Write your MySQL query statement belowselect A.Name as Employee  from Employee AS A,Employee AS B WHERE A.ManagerId = B.Id And A.Salary &gt; B.Salary;</code></pre><h2 id="查找重复的电子邮箱"><a href="#查找重复的电子邮箱" class="headerlink" title="查找重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/" rel="external nofollow noreferrer">查找重复的电子邮箱</a></h2><p>编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</p><pre><code>示例：+----+---------+| Id | Email   |+----+---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |+----+---------+</code></pre><p>根据以上输入，你的查询应返回以下结果：</p><pre><code>+---------+| Email   |+---------+| a@b.com |+---------+说明：所有电子邮箱都是小写字母。</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"># Write your MySQL query statement below-- select Email, count(*) as Num  from Person group by Email;-- select Email from t where Num &gt;1select Email from (select Email, count(*) as Num  from Person group by Email) t where t.Num &gt; 1;</code></pre><h2 id="从不订购的客户"><a href="#从不订购的客户" class="headerlink" title="从不订购的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/" rel="external nofollow noreferrer">从不订购的客户</a></h2><p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p>Customers 表：</p><pre><code>+----+-------+| Id | Name  |+----+-------+| 1  | Joe   || 2  | Henry || 3  | Sam   || 4  | Max   |+----+-------+</code></pre><p>Orders 表：</p><pre><code>+----+------------+| Id | CustomerId |+----+------------+| 1  | 3          || 2  | 1          |+----+------------+</code></pre><p>例如给定上述表格，你的查询应返回：</p><pre><code>+-----------+| Customers |+-----------+| Henry     || Max       |+-----------+</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"># Write your MySQL query statement below-- select Name as Customers from Customers Where Id not in (select Orders.CustomerId from Orders );select c.Name as Customers from Customers cleft join Orders o on c.Id = O.CustomerIdWhere o.CustomerId is null;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>表1: Person</p><pre><code></code></pre><p>表2: Address</p><pre><code></code></pre><p>编写一个 SQL 查询</p><pre><code>FirstName, LastName, City, State</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"></code></pre><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><p>表1: Person</p><pre><code></code></pre><p>表2: Address</p><pre><code></code></pre><p>编写一个 SQL 查询</p><pre><code>FirstName, LastName, City, State</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"></code></pre><h2 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h2><p>表1: Person</p><pre><code></code></pre><p>表2: Address</p><pre><code></code></pre><p>编写一个 SQL 查询</p><pre><code>FirstName, LastName, City, State</code></pre><p><strong>[ 解题 ]</strong></p><pre><code class="mysql"></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端领域</category>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>leetcode</tag>
      
      <tag>牛客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 经典面试题</title>
    <link href="/alwaysblog/post/4225305543/"/>
    <url>/alwaysblog/post/4225305543/</url>
    
    <content type="html"><![CDATA[<h3 id="取得每个部门最高薪水的人员名称"><a href="#取得每个部门最高薪水的人员名称" class="headerlink" title="取得每个部门最高薪水的人员名称"></a>取得每个部门最高薪水的人员名称</h3><pre><code class="sql">-- 分析-- 第一步： 求出每个部门最高的薪水SELECT     e.deptno,MAX(e.sal) as maxsalFROM emp eGROUP BY     e.deptno;-- 将以上查询结果当成一个临时表 t(deptno,maxsal)-- 最高薪水的人员名称（两张表的连接）SELECT     e.deptno,e.ename,t.maxsal,e.salFROM     (SELECT e.deptno,MAX(e.sal) AS maxsal      FROM emp e      GROUP BY e.deptno;) tJOIN emp e ON t.deptno = e.deptnoWHERE t.maxsal = e.sal ORDER BY e.deptno;</code></pre><h3 id="那些人的薪水在部门的平均薪水之上"><a href="#那些人的薪水在部门的平均薪水之上" class="headerlink" title="那些人的薪水在部门的平均薪水之上"></a>那些人的薪水在部门的平均薪水之上</h3><pre><code class="sql">-- 分析 -- 第一步，求出部门的平均薪水SELECT     e.deptno, AVG(e.sal) AS avgsalFROM     emp eGROUP BY e.deptno; -- 将以上查询结果当成一个临时表 t(deptno,avgsal)-- 薪水在部门的平均薪水之上的人员（两张表的连接）SELECT e.deptno,e.ename,e.sal,t.avgsal FROM     (SELECT e.deptno, AVG(e.sal) AS avgsal      FROM emp e      GROUP BY e.deptno;) tJOIN emp e ON t.deptno = e.deptnoWHERE e.sal &gt; t.avgsalORDER BY e.deptno;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端领域</category>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础</title>
    <link href="/alwaysblog/post/1206568676/"/>
    <url>/alwaysblog/post/1206568676/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><blockquote><p>关系型数据库： 以二维表存储数据</p></blockquote><h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><ul><li>数据表的创建</li></ul><pre><code class="sql">-- unsigned: 无符号-- primary key： 主键-- auto_increment： 自动递增create table demo (    id int unsigned primary key auto_increment,    name varchar(10),    age int unsigned)</code></pre><ul><li>数据表的删除</li></ul><pre><code class="sql">-- 删除掉 demo 表drop table demo;-- 如果数据库中存在demo表，就把它从数据库中drop掉。drop table if exists demo;-- 使用场景drop table if exists demo;create table demo (    id int unsigned primary key auto_increment,    name varchar(10),    age int unsigned)</code></pre><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li>增<br>```sql</li><li><ul><li>单条添加<br>insert into demo values(null, “鲁班”, 20);</li></ul></li></ul><p>– 多条添加<br>insert into demo(name, age) values(“鲁班大师”, 50),(“凯”, 32),(“安琪拉”, 20), … …</p><pre><code>- 删```sql-- 删除表中所有数据delete from demo;-- 按条件删除数据delete from demo where name =&quot;鲁班大师&quot;;  ==&gt; 删除 name 是 鲁班大师的整条数据</code></pre><ul><li>改<br>```sql<br>update demo set name = “小乔”, age = 20 where id = 10;</li></ul><pre><code>- 查```sqlselect * from demo;select name, age from demo;-- 条件查询select name from demo where id = 1;-- where 支持多种运算符   - 比较运算符： =, &gt;, &lt;, &gt;=, &lt;=, !=   - 逻辑运算符： and(且), or(或), not(非)   - 模糊查询： like ==&gt; %, _      + where name like &#39;孙%&#39;     + where name like &#39;孙_&#39;     + where name like &#39;%孙%&#39;     + where name like &#39;_ _&#39;   - 范围查询 in(&#39;男&#39;, 女), between 18 and 20   - 空判断： null , isnull-- 设置别名select name as 姓名, age as 年龄 from demo;-- 数据表设置别名select D.name, D.age from demo as D;</code></pre><ul><li>去掉字段中重复的数据<br>```sql<br>select distinct sex from student;</li></ul><p>– 去掉多个字段中重复的数据<br>select distinct sex, class from student;</p><pre><code>- 排序```sqlselect * from student order by age;-- 升序： order by age asc (默认)-- 降序： order by age desc-- 多次排序select * from student order by age,id desc 先年龄正序，id降序-- 中文排序select * from student order by convert(name using gbk)</code></pre><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li><p>count 统计</p><pre><code class="sql">select count(*) from student;  ==&gt; 只要有值就统计     count(name)</code></pre></li><li><p>max 最大值</p><pre><code class="sql">select max(age) from student;  </code></pre></li><li><p>min 最小值</p><pre><code class="sql">select min(age) from student;  </code></pre></li><li><p>sum 求和</p><pre><code class="sql">select sum(age) from student;  </code></pre></li><li><p>avg 平均值</p><pre><code class="sql">select avg(age) from student;  </code></pre><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3></li><li><p>group by 根据某一字段排序，可以去重<br>```sql</p></li><li><ul><li>每个班级的平均，最大年龄<br>select class, avg(age), max(age) from student group by class;<br>```<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3></li></ul></li><li><p>等值查询</p><pre><code class="sql">select * from student as stu, score as sc where stu.sid = sc.sid;</code></pre></li><li><p>内查询</p><pre><code class="sql">select * from student as stuinner join score as sc on stu.sid = sc.sid;</code></pre></li><li><p>多表连接(两两之间产生条件)</p><pre><code class="sql">select * from student as stuinner join score as sc on stu.sid = sc.sidinner join course as co on sc.cid = co.cid;</code></pre></li><li><p>自关联（同一个表查询多次，自己产生关联，表必须起别名）</p><pre><code class="sql">select * from areas as shenginner join areas as shi on sheng.pid = shi.pid</code></pre></li><li><p>左连接（jion 前边的表）</p><pre><code class="sql">select * from student as stuleft join score as sc on stu.sid = sc.sid;</code></pre></li><li><p>右连接</p><pre><code class="sql">select * from student as sturight join score as sc on stu.sid = sc.sid;</code></pre></li><li><p>子查询<br>```sql</p></li><li><ul><li>查询大于平均年龄的学生<br>select * from student whrer age &gt; (select avg(age) from student);<br>```</li></ul></li><li><p>数据分表<br>```sql<br>create table newStudent (<br>  id int unsigned primary key auto_increment,<br>  name varchar(10),<br>  age int unsigned<br>)</p></li><li><ul><li>查询的数据插入到另一个表中（查询出来的列必须对应表中的字段名，否则会新建）<br>insert into newStudent(id, name, age )  select id,name,age from student;</li></ul></li></ul><p>– 创建并直接插入（查询出来的列必须对应表中的字段名，否则会新建）<br>create table newStudent (<br>    id int unsigned primary key auto_increment,<br>    Sname varchar(10)<br>) select name as Sname  from student;</p><pre><code>### 索引（作用于某个字段）**加索引后会使写入、修改、删除变慢，每一次增加数据平衡树都会重新排列，也会增加表的体积，占用磁盘存储空间。**- 查看索引```sql    show index from 表名;</code></pre><ul><li>创建索引（创建索引后，表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是「平衡树」结构）<br>```sql</li><li><ul><li>建表时创建索引 key (age)、primary key、unique<br>create table newStudent (<br> id int unsigned primary key auto_increment,<br> name varchar(10) unique<br> age int unsigned,<br> key (age)<br>)</li></ul></li></ul><p>– 已经存在的表创建索引<br>create index 索引名称 on 表名(字段名(长度))<br>create index i_index on newStudent(name(10))</p><p>```</p>]]></content>
    
    
    <categories>
      
      <category>后端领域</category>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb 常用命令</title>
    <link href="/alwaysblog/post/2030954057/"/>
    <url>/alwaysblog/post/2030954057/</url>
    
    <content type="html"><![CDATA[<ul><li>列出所有的连接设备</li></ul><pre><code>adb devices</code></pre><ul><li>拷⻉⽂件/⽬录到设备</li></ul><pre><code> adb push E:/images/test.jpg /sdcard/</code></pre><ul><li>从设备拷⻉⽂件/⽬录</li></ul><pre><code> adb pull /sdcard/images/test.jpg E:\tmp</code></pre><ul><li>浏览设备⽇志</li></ul><pre><code> adb logcat</code></pre><ul><li>列出所有包名</li></ul><pre><code> adb shell pm list packages</code></pre><ul><li>安装 apk ⽂件</li></ul><pre><code> adb install [apk路径] 覆盖安装： adb install -r [apk路径]</code></pre><ul><li>卸载 app</li></ul><pre><code> adb uninstall com.xx.xx 保留app数据：  adb uninstall -k com.xx.xx</code></pre><ul><li>查看 package name，启动应⽤后输⼊命令</li></ul><pre><code> windows环境下: adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot; Linux、Mac环境下： adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code></pre><ul><li>截图</li></ul><pre><code> adb shell screencap /sdcard/screen.png</code></pre><ul><li>app 启动时间测试</li></ul><pre><code> 1. logcat⽅法，命令：  adb shell logcat -v time |findstr ActivityManager  取第⼀个activity的启动时间点，最后⼀个activity的展示完成的时间点，相减得到启动时间。（系统⻆度） 2. 录屏⽅式 ⼿⼯点击app到客户端启动，多次取平均值（⽤户⻆度）</code></pre><p><strong>adb shell</strong></p><ul><li>adb shell 进⼊ Android 设备环境</li><li>设备基本信息：</li></ul><pre><code> 命令：cat /system/build.prop | grep &quot;product&quot;</code></pre><pre><code>1 ro.product.model          ⼿机代号也就是⼿机名2 ro.product.brand          ⼿机品牌3 ro.product.name           ⼿机正式名称4 ro.product.device         ⼿机采⽤的设备5 ro.product.board          ⼿机采⽤的处理器6 ro.product.cpu.abi        cpu的版本7 ro.product.cpu.abi2       cpu的品牌8 ro.product.manufacturer   ⼿机制造商9 o.product.locale.language ⼿机默认语⾔10 ro.product.locale.region 地区语⾔11 ro.build.product         建⽴产品</code></pre><ul><li>获取 cpu 信息</li></ul><pre><code>命令：cat /proc/cpuinfo</code></pre><pre><code>1 processor：     系统中逻辑处理核的编号。对于单核处理器，则课认为是其CPU编号，对于多核处理器则可以是物理核、或者使⽤超线程技术虚拟的逻辑核2 vendor_id：     CPU制造商3 cpu family：    CPU产品系列代号4 model：         CPU属于其系列中的哪⼀代的代号5 model name：    CPU属于的名字及其编号、标称主频6 stepping ：     CPU属于制作更新版本7 cpu MHz ：      CPU的实际使⽤主频8 cache size ：   CPU⼆级缓存⼤⼩9 physical id ：  单个CPU的标号10 siblings ：    单个CPU逻辑物理核数11 core id ：     当前物理核在其所处CPU中的编号，这个编号不⼀定连续12 cpu cores ：   该逻辑核所处CPU的物理核数13 apicid ：      ⽤来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不⼀定连续14 fpu ：         是否具有浮点运算单元（Floating Point Unit）15 fpu_exception ：是否⽀持浮点计算异常16 cpuid level ：  执⾏cpuid指令前，eax寄存器中的值，根据不同的值cpuid指令会返回不同的内容17 wp ：           表明当前CPU是否在内核态⽀持对⽤户空间的写保护（Write Protection）18 flags ：        当前CPU⽀持的功能19 bogomips ：     在系统内核启动时粗略测算的CPU速度（Million Instructions Per Second）20 clflush size ： 每次刷新缓存的⼤⼩单位21 cache_alignment：缓存地址对⻬单位22 address sizes ： 可访问地址空间位数</code></pre><ul><li>获取设备内存</li></ul><pre><code>命令：cat /proc/meminfo</code></pre><pre><code>1 MemTotal:     所有可⽤RAM⼤⼩（即物理内存减去⼀些预留位和内核的⼆进制代码⼤⼩）2 MemFree:      LowFree与HighFree的总和，被系统留着未使⽤的内存3 Buffers:      ⽤来给⽂件做缓冲⼤⼩4 Cached:       被⾼速缓冲存储器（cache memory）⽤的内存的⼤⼩（等于 diskcache minus SwapCache ）5 SwapCached:   被⾼速缓冲存储器（cache memory）⽤的交换空间的⼤⼩，已经被交换出来的内存，但仍然被存放在swapfile中。⽤来在需要的时候很快的被替换⽽不需要再次打开6 Active:       在活跃使⽤中的缓冲或⾼速缓冲存储器⻚⾯⽂件的⼤⼩，除⾮⾮常必要否则不会被移作他⽤7 Inactive:     在不经常使⽤中的缓冲或⾼速缓冲存储器⻚⾯⽂件的⼤⼩，可能被⽤于其他途径.8 HighTotal:9 HighFree:     该区域不是直接映射到内核空间。内核必须使⽤不同的⼿法使⽤该段内存。10 LowTotal:11 LowFree:     低位可以达到⾼位内存⼀样的作⽤，⽽且它还能够被内核⽤来记录⼀些⾃⼰的数据结构。Among many12 other things, it is where everything from the Slab is allocated13 SwapTotal:   交换空间的总⼤⼩14 SwapFree:    未被使⽤交换空间的⼤⼩15 Dirty:       等待被写回到磁盘的内存⼤⼩。16 Writeback:   正在被写回到磁盘的内存⼤⼩。17 AnonPages：  未映射⻚的内存⼤⼩18 Mapped:      设备和⽂件等映射的⼤⼩。19 Slab:        内核数据结构缓存的⼤⼩，可以减少申请和释放内存带来的消耗。20 SReclaimable:可收回Slab的⼤⼩21 SUnreclaim： 不可收回Slab的⼤⼩（SUnreclaim+SReclaimable＝Slab）22 PageTables： 管理内存分⻚⻚⾯的索引表的⼤⼩。23 NFS_Unstable:不稳定⻚表的⼤⼩24 VmallocTotal:可以vmalloc虚拟内存⼤⼩25 VmallocUsed: 已经被使⽤的虚拟内存⼤⼩。26 VmallocChunk: largest contigious block of vmalloc area which is free</code></pre>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
      <category>移动端测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>移动端测试</tag>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试面试总结</title>
    <link href="/alwaysblog/post/108766007/"/>
    <url>/alwaysblog/post/108766007/</url>
    
    <content type="html"><![CDATA[<h2 id="第一家"><a href="#第一家" class="headerlink" title="第一家"></a>第一家</h2><ol><li>主要是做功能测试吗？</li><li>在工作中用到些什么工具？</li><li>印象比较深刻的项目？是一个人测试的吗？</li><li>协助开发搭建环境，简单说一下是怎么做的？</li><li>接口测试的话你是怎么做一个参数化的？接口测试里面有做过关联吗？用的是哪个元件？正则表达式提取器有用过吗？</li><li>有没有遇到过印象深刻的 bug？</li><li>项目有需求分析这个环节吗？需求评审的时候，有没有总结过产品经常会漏掉些什么功能，需求文档会出现什么 bug，你有没有去总结一下？比如哪里的逆向的思维没有考虑到，数据显示有问题，没有换行这样子</li><li>有用 fiddler 抓包做测试吗？</li><li> 你这个项目有做过性能测试吗？性能测试的基本流程是怎样的？</li><li>你不用去了解一下哪些地方需要做压测吗？哪些地方是有压力点的？</li><li>并发数我们要怎么确定呢？</li><li>你平时通过上面渠道去学 python？</li><li>python 主要数据类型有哪些？</li><li>假如有一个预约口罩的功能，</li></ol><ul><li>每天只能预约一次；</li><li>每天晚上 8 点公布前一天的预约结果；</li><li>每次预约时需要提交一个表单，表格里包括身手机号，身份证号等信息。你针对这个来说一说有哪些测试点。越多越好</li></ul><p> <strong>预约次数，是否准时公布结果，公布结果是否正确，表单是否必填，手机号长度、号段、特殊字符，身份证长度，末尾最后一项，提交按钮是否正常响应，预约信息是否添加数据库，预约人数限制，预约地区限制，预约条件、身份认证</strong></p><ol start="15"><li> SQL 注入</li></ol><h2 id="第二家"><a href="#第二家" class="headerlink" title="第二家"></a>第二家</h2><ol><li>左连接和右连接的区别？</li><li>什么情况下使用索引？</li><li>索引有哪些？</li><li>不同索引的使用场景？</li><li>使用索引之后的查询速度比不使用索引的查询速度要快，是这样吗？</li><li>什么时候使用索引会查询的快？</li><li>工作中有遇到过哪些让你有成就感的事情，可以说个两三件吗？</li><li>说说你在开发或者测试工作中遇到过哪些困难？</li><li>你平时的测试是点点点还是借助某些工具去测试还是说纯写测试脚本代码的？</li><li>比如你一个 OA 系统里面功能比较多，你是通过手工快速去点还是用什么方式去快速完成这个测试工作？</li></ol><ul><li>如果是新功能开发的测试阶段，肯定是需要点点点</li><li>如果是老功能做回归测试，则需要做自动化测试</li></ul><ol><li> 个人规划是怎么样的？</li><li> 你们公司主要有哪些功能模块？</li><li> 对加班和出差怎么看？</li></ol><h2 id="第三家"><a href="#第三家" class="headerlink" title="第三家"></a>第三家</h2><ol><li>上家公司做什么的？</li><li>上家公司的测试流程？</li><li>用例评审是哪些人员参与的？</li><li>常见的状态码？</li><li>fiddler 的原理？能抓 https 的包吗？</li></ol><ul><li>Fiddler 是位于客户端和服务器端的 HTTP 代理，能够记录客户端和服务器之间的所有 HTTP 请求，可以针对特定的 HTTP 请求，分析或修改请求数据，也可以修改服务器返回的数据。</li></ul><ol><li>http 和 https 的区别？</li><li>一般用到什么方法来写测试用例？</li><li>怎么区分 bug 是前端还是后端？</li><li>可以用 loaderrunner 做什么？</li><li>怎么用 jmeter 来做测试的？</li><li>你可以说说 jmeter 里的进程和线程吗？</li><li>jmeter 里怎么看报错的？</li><li>你说说聚合报告是个什么东西？</li><li>性能测试的流程？</li><li>实际没有达到预想的性能测试指标值，你怎么办？有哪些因素可能会造成这样？</li><li>你说一些 linux 命令，chmod 命令是干嘛的？怎么查看端口被占用？</li><li>你以前的工作中的 jenkins 起到什么作用？</li><li>py 中 init 方法和 new 方法有什么作用？</li><li>怎么定位网页上的元素的？</li><li>有没有用过 django 框架？</li><li>你知道深拷贝和浅拷贝的区别吗？</li><li>你知道什么是装饰器吗？</li><li>git 是干嘛的？git 和 svn 有什么区别？</li><li>一张表里有很多数据，为什么查询张三这个数据很慢？索引的本质或者原理是什么？</li><li>一个测试需要具备什么素质？</li><li>你自身的优势在哪里？</li><li>说一下 cookies 和 session，token。服务器是怎么知道你这个登录的用户是哪个用户？</li></ol><h2 id="（正式面试）"><a href="#（正式面试）" class="headerlink" title="（正式面试）"></a>（正式面试）</h2><ul><li><p>网络协议怎么理解</p></li><li><p>http 和 https 的区别</p></li><li><p>tcp/ip 协议</p></li><li><p>html css js 在页面中充当什么角色</p></li><li><p>html css js 各会出现什么样的 bug</p></li><li><p>测试流程</p></li><li><p>你平常用 linux 做什么操作</p></li><li><p>怎么搭建环境</p></li><li><p>怎么自动化搭建环境</p></li><li><p>怎么做自动化接口测试</p></li><li><p>你在项目中做的接口测试的占比</p></li><li><p>平常你们的项目是怎么开展的</p></li><li><p>你在迭代过程中的每个时间段都做什么？</p></li><li><p>怎么和同事分享你所知道的新的技术</p></li><li><p>上级给你一个方案，但是你有更好的解决方案，你会怎么做？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试面试</title>
    <link href="/alwaysblog/post/2734300636/"/>
    <url>/alwaysblog/post/2734300636/</url>
    
    <content type="html"><![CDATA[<h2 id="软件测试方法的分类"><a href="#软件测试方法的分类" class="headerlink" title="软件测试方法的分类"></a>软件测试方法的分类</h2><div align="center"><p><img src="https://i.loli.net/2020/05/28/PcGbk4dYFfXLTzj.png" alt="软件测试分类.png"></p></div><h2 id="常用测试方法"><a href="#常用测试方法" class="headerlink" title="常用测试方法"></a>常用测试方法</h2><div align="center"><p><img src="https://i.loli.net/2020/05/28/seV7fQw169kG5dh.png" alt="测试方法.png"></p></div><h2 id="系统测试方法"><a href="#系统测试方法" class="headerlink" title="系统测试方法"></a>系统测试方法</h2><div align="center"><p><img src="https://i.loli.net/2020/05/28/7uieAb1MB3VH8ZR.png" alt="系统测试.png"></p></div><h2 id="什么是软件测试"><a href="#什么是软件测试" class="headerlink" title="什么是软件测试"></a>什么是软件测试</h2><ul><li>软件测试是利⽤测试⼯具按照测试⽅法和流程对开发出来的产品进⾏功能、性能、安全等的测试。满⾜产品需求。</li></ul><h2 id="软件产品质量模型（ISO-IEC-9126）"><a href="#软件产品质量模型（ISO-IEC-9126）" class="headerlink" title="软件产品质量模型（ISO / IEC 9126）"></a>软件产品质量模型（ISO / IEC 9126）</h2><ul><li>功能性：提供满足明确和隐含要求的功能的能力</li><li>可靠性：在特定条件下使用时，软件产品呢维持规定的性能级别能力<ul><li>设备最好不要出故障</li><li>设备出故障了，不要影响主要的功能和业务</li><li>如果影响了主要功能和业务，系统可以尽快定位并恢复</li></ul></li><li>易用性：易懂、易学、易用、漂亮好看（用户体验好）</li><li>效率：软件产品可提供适当的性能的能力，也就是产品的性能（单选、多选、全选）</li><li>可维护性：产品可以被修改的能力。可以增加功能，可以更新。</li><li>可移植性：跨越不同系统平台</li></ul><h3 id="对一支笔从软件质量的体系进行分析要测哪些？"><a href="#对一支笔从软件质量的体系进行分析要测哪些？" class="headerlink" title="对一支笔从软件质量的体系进行分析要测哪些？"></a>对一支笔从软件质量的体系进行分析要测哪些？</h3><ul><li>功能： 是否可以写出字，字的颜色，字的粗细，笔的重量，笔的材质，笔的尺寸</li><li>性能： 一支笔能连续写多久，从高处掉落会不会坏</li><li>易用性： 是否美观，是否好握，书写是否舒服</li><li>安全： 材质是否符合安全规范，是否对人体产生危害</li><li>可移植性： 是否可以通过换笔芯继续使用。</li></ul><h2 id="Web-测试与-App-测试"><a href="#Web-测试与-App-测试" class="headerlink" title="Web 测试与 App 测试"></a>Web 测试与 App 测试</h2><h3 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h3><p>我们会先进行需求评审，根据需求并书写测试用例，然后和其他测试人员交换用例，以达到用例评审的目的，修改遗漏和错误的测试用例，等待开发提测，如果期间接口设计完成，我们会先对接口进行测试，开发提测以后，根据测试用例对项目进行测试，如果出现 Bug，会将Bug 提交给对应开发人员，开发人员修复以后，需要对 Bug 再次进行测试，如果涉及到其他功能，也需要对它们进行测试，如果还是有问题，继续提交给对应开发人员，直到整个项目测试完成。另外在项目上线前，需要对项目的重要功能进行测试，确保项目可以正常上线，上线后，对重要功能再次进行测试确保用户可以正常使用，同时也需要持续关注项目的各个功能是否正常。</p><h3 id="App-测试流程"><a href="#App-测试流程" class="headerlink" title="App 测试流程"></a>App 测试流程</h3><p>我们会先进行需求评审，然后根据需求书写测试用例，然后和其他测试人员交换用例，以达到用例评审的目的，修改遗漏和错误的测试用例，等待开发提测，开发提测后，我们会先进行冒烟测试，看一下项目的主流程是否可以走通，然后进行功能测试和接口测试，完成以后，对 App 的安装卸载进行测试包括 App 的覆盖安装和升级，再然后会对 App 在断网和弱网的环境下进行测试，最后对 App 的兼容性进行测试，全部测完以后对整个项目进行回归测试，以便项目可以正常上线。上线后，对重要功能再次进行测试确保用户可以正常使用，同时也需要持续关注项目的各个功能是否正常。</p><h3 id="Web-测试与-App-测试的区别"><a href="#Web-测试与-App-测试的区别" class="headerlink" title="Web 测试与 App 测试的区别"></a>Web 测试与 App 测试的区别</h3><ul><li><p>从功能测试的层面上来讲的话，App 测试、Web 测试 在流程和功能测试上是没有区别的。</p></li><li><p>系统架构方面：</p><ul><li>Web 项目，一般都是 b/s 架构，基于浏览器的</li><li>App 项目，则是 c/s 的，必须要有客户端，用户需要安装客户端。</li><li>Web 测试只要更新了服务器端，客户端就会同步会更新。App 项目则需要客户端和服务器都更新。</li></ul></li><li><p>性能方面:</p><ul><li>Web 页面主要会关注响应时间</li><li>而 App 则还需要关心流量、电量、CPU、GPU、Memory 这些。</li><li>它们服务端的性能没区别，都是一台服务器。</li></ul></li><li><p>兼容方面：</p><ul><li>Web 是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 ，所以 Web 测试不必考虑安装卸载</li><li>App 测试是基于客户端的，则要看分辨率，屏幕尺寸，还要看设备系统。</li></ul></li></ul><p>所以 App 测试则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件<br>此外 App 还有一些专项测试：如网络、适配性。。。</p><h3 id="App-测试特点"><a href="#App-测试特点" class="headerlink" title="App 测试特点"></a>App 测试特点</h3><p><strong>（除了按需求说明书外的 功能测试 之外还需要进行如下测试）</strong></p><ul><li>适配性测试（也叫兼容性测试，不同的安卓版本，不同厂商，不同手机品牌）</li><li>不同网络测试 （2G 网络/3G 网络/4G 网络/WIFI 网络）</li><li>在线升级测试</li><li>中断测试（电话、短中消息打扰）</li><li>耗电量测试</li><li>弱网测试（信号差，信号屏蔽实验室）</li><li>安装卸载 （C/S）</li><li>流量测试</li></ul><h2 id="系统测试是什么，有哪些测试方法。流程是什么"><a href="#系统测试是什么，有哪些测试方法。流程是什么" class="headerlink" title="系统测试是什么，有哪些测试方法。流程是什么?"></a>系统测试是什么，有哪些测试方法。流程是什么?</h2><p>[ 系统测试 ]</p><ul><li>对项目进行全面的测试，其中包含单元测试和集成测试</li></ul><p>[ 测试方法 ]</p><ul><li>功能测试</li><li>异常测试</li><li>性能测试</li><li>易用性测试</li><li>安全性测试</li><li>GUI 测试</li><li>兼容性测试</li><li>配置测试</li><li>安装测试</li></ul><p>[ 流程 ]</p><p>我们拿到需求以后，根据需求书写测试用例，然后和其他测试人员交换用例，以达到用例评审，然后修改遗漏和错误的测试用例，等待开发完成，然后测试项目，如果出现 Bug， Bug 用工具指向开发人员，开发人员修改后，对 Bug 进行测试，并对其关联的模块进行测试，如果没有问题继续测试，如果还有问题，继续指向开发人修改，如此往复直到么有问题为止。</p><h2 id="测试用例的设计方法"><a href="#测试用例的设计方法" class="headerlink" title="测试用例的设计方法"></a>测试用例的设计方法</h2><ul><li>等价类划分法</li><li>边界值分析法</li><li>因果图/判定表法</li><li>错误推断法</li><li>正交实验法</li><li>场景设计法/流程分析法</li></ul><h2 id="http-协议-和-https-协议"><a href="#http-协议-和-https-协议" class="headerlink" title="http 协议 和 https 协议"></a>http 协议 和 https 协议</h2><h3 id="http-协议"><a href="#http-协议" class="headerlink" title="http 协议"></a>http 协议</h3><ul><li>HTTP 协议： 超文本传输协议</li></ul><p>[ 请求方式 ]</p><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>[ 状态码 ]</p><ul><li>200 成功</li><li>204 请求成功，服务端没有内容</li><li>301 永久重定向</li><li>302 临时重定向</li><li>304 走缓存</li><li>400 参数错误</li><li>401 权限不够</li><li>403 服务器拒绝响应</li><li>404 资源不存在</li><li>500 服务器端错误，</li><li>502 网关错误</li></ul><h3 id="http-协议-和-https-协议的区别"><a href="#http-协议-和-https-协议的区别" class="headerlink" title="http 协议 和 https 协议的区别"></a>http 协议 和 https 协议的区别</h3><ul><li>http 协议是超文本传输协议，信息是明文传输</li><li>https 是具有安全性的 ssl / tls 加密传输协议</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li><li>http 的连接很简单，是无状态的; HTTPS 协议是由 SSL/TLS+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</li></ul><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>TCP（Transmission Control Protocol，传输控制协议）<br>UDP（User Data Protocol，用户数据报协议）</p><p>1、基于连接与无连接；</p><p>2、对系统资源的要求（TCP较多，UDP少）；</p><p>3、UDP程序结构较简单；</p><p>4、流模式与数据报模式 ；</p><p>5、TCP保证数据正确性，UDP可能丢包；</p><p>6、TCP保证数据顺序，UDP不保证。</p><h2 id="接口测试流程"><a href="#接口测试流程" class="headerlink" title="接口测试流程"></a>接口测试流程</h2><ul><li>接口的功能测试（先保证接口是正确的）</li><li>测试接口的数据（传递一些特殊的数据，保证接口没有问题）</li><li>自动化测试脚本的编辑</li><li>接口的性能、压力测试</li></ul><blockquote><ul><li>HTTP: 超文本传输协议，浏览器和服务器之间通信的规则</li><li>URL: 统一资源定位符，协议://主机地址/路径</li><li>GET: 提交的数据显示在地址栏，不安全，提交的数据量有限制，不重要的数据使用 GET</li><li>POST: 隐式提交数据，更安全，没有数据量大小的限制，重要数据使用 POST</li></ul></blockquote><h3 id="Fiddler-的原理"><a href="#Fiddler-的原理" class="headerlink" title="Fiddler 的原理"></a>Fiddler 的原理</h3><ul><li>Fiddler 是位于客户端和服务器端的 HTTP 代理，能够记录客户端和服务器之间的所有 HTTP 请求，可以针对特定的 HTTP 请求，分析或修改请求数据，也可以修改服务器返回的数据。</li></ul><h3 id="你可以说说-jmeter-里的进程和线程吗？"><a href="#你可以说说-jmeter-里的进程和线程吗？" class="headerlink" title="你可以说说 jmeter 里的进程和线程吗？"></a>你可以说说 jmeter 里的进程和线程吗？</h3><h3 id="你说说聚合报告是个什么东西？"><a href="#你说说聚合报告是个什么东西？" class="headerlink" title="你说说聚合报告是个什么东西？"></a>你说说聚合报告是个什么东西？</h3><ul><li>对于每个请求，它统计响应信息并提供请求数，平均值，最大，最小值，错误率，大约吞吐量(以请求数/秒为单位)和以kb/秒为单位的吞吐量.</li></ul><h2 id="缺陷（Bug）管理"><a href="#缺陷（Bug）管理" class="headerlink" title="缺陷（Bug）管理"></a>缺陷（Bug）管理</h2><h3 id="一个“缺陷”的记录都包含哪些内容"><a href="#一个“缺陷”的记录都包含哪些内容" class="headerlink" title="一个“缺陷”的记录都包含哪些内容"></a>一个“缺陷”的记录都包含哪些内容</h3><ul><li>所属产品、模块、项目、版本</li><li>Bug 指派</li><li>Bug 标题</li><li>优先级</li><li>严重程度</li><li>操作步骤</li><li>实际结果</li><li>预期结果</li></ul><h3 id="怎么区分-Bug-是前端的还是后端的"><a href="#怎么区分-Bug-是前端的还是后端的" class="headerlink" title="怎么区分 Bug 是前端的还是后端的"></a>怎么区分 Bug 是前端的还是后端的</h3><ol><li>如果项目崩溃，就是前端的 Bug</li><li>界面出现问题，前端 Bug</li><li>资源不能加载（根据状态码）</li></ol><ul><li>500： 后端的问题</li><li>404：</li><li><ul><li>查看前端有没有发出去请求</li><li>查看前端请求接口是不是对的</li><li>查看前端请求参数是否正确</li></ul></li><li>200：<ul><li>后端返回的数据是否正确</li><li>前端读取数据的时候出错 </li></ul></li></ul><h3 id="优先级与严重程度"><a href="#优先级与严重程度" class="headerlink" title="优先级与严重程度"></a>优先级与严重程度</h3><h4 id="Bug-优先级（Bug-修复的先后顺序，针对于测试人员）"><a href="#Bug-优先级（Bug-修复的先后顺序，针对于测试人员）" class="headerlink" title="Bug 优先级（Bug 修复的先后顺序，针对于测试人员）"></a>Bug 优先级（Bug 修复的先后顺序，针对于测试人员）</h4><ul><li>一级： 严重影响到后面功能模块的测试工作</li><li>二级： Bug 会制约开发和测试的活动进行，需要在发布前修复</li><li>三级： 不影响其他工作，文字，话术、图片等出现错误</li></ul><h4 id="Bug-严重程度（从用户角度考虑）"><a href="#Bug-严重程度（从用户角度考虑）" class="headerlink" title="Bug 严重程度（从用户角度考虑）"></a>Bug 严重程度（从用户角度考虑）</h4><ul><li>一级：致命问题，App 崩溃</li><li>二级：功能出现错误，</li><li>三级：UI 界面出现错误（文字，话术、图片等）</li></ul><h4 id="测试用例优先级"><a href="#测试用例优先级" class="headerlink" title="测试用例优先级"></a>测试用例优先级</h4><ul><li>一级：正向的流程，主功能</li><li>二级：反向的流程</li><li>三级：检查 UI 界面的文本、图片等</li></ul><h2 id="冒烟测试和回归测试的区别"><a href="#冒烟测试和回归测试的区别" class="headerlink" title="冒烟测试和回归测试的区别"></a>冒烟测试和回归测试的区别</h2><ul><li>测试目的不同<ul><li>冒烟测试：用于确认代码中的更改会按预期运行，且不会破坏整个版本的稳定性。</li><li>回归测试：以确认修改没有引入新的错误或导致其他代码产生错误。</li></ul></li><li>测试过程不同<ul><li>冒烟测试：是在将代码更改嵌入到产品的源树中之前对这些更改进行验证的过程。</li><li>回归测试：是指漏洞由开发人员修改之后再次测试的过程。</li></ul></li><li>问题解决方式不同<ul><li>冒烟测试：冒烟测试中是发现问题然后反馈给开发人员进行修改。</li><li>回归测试：回归测试是修改完之后进行验证再进行的工程。</li></ul></li><li>测试周期不同<ul><li>冒烟测试：冒烟测试只集中考虑了一开始的那个问题，而忽略其它的问题，这就可能引起了新的 Bug，SmokeTest 优点是节省测试时间。</li><li>回归测试：回归测试作为软件生命周期的一个组成部分，在整个软件测试过程中占有很大的工作量比重，软件开发的各个阶段都会进行多次回归测试。</li></ul></li><li>测试意义不同<ul><li>冒烟测试：冒烟测试是对软件质量的总体检验，是测试人员对测试流程的熟悉，是软件测试过程中一个不可或缺的节点，一个好的冒烟测试过程，对于软件测试效率的提升具有重要意义。</li><li>回归测试：回归测试是软件测试中的一个十分重要且成本昂贵的过程。对针对如何减少回归测试成本，提高回归测试效率的研究将具有十分重要的意义。</li></ul></li></ul><h2 id="git-是干嘛的？git-和-svn-有什么区别？"><a href="#git-是干嘛的？git-和-svn-有什么区别？" class="headerlink" title="git 是干嘛的？git 和 svn 有什么区别？"></a>git 是干嘛的？git 和 svn 有什么区别？</h2><ul><li>git 是分布式版本控制系统，SVN 是集中式版本控制系统，这两个都是管理代码的</li><li>svn 严重的依赖服务器端，当服务器端无法使用的时候，版本控制也就无法再使用了。</li><li>git 当这个系统的任何一个客户端出现问题的时候，都可以从另外的客户端（即使服务器挂了）获取所有的代码。</li></ul><h2 id="说一下-cookies-和-session，token。服务器是怎么知道你这个登录的用户是哪个用户？"><a href="#说一下-cookies-和-session，token。服务器是怎么知道你这个登录的用户是哪个用户？" class="headerlink" title="说一下 cookies 和 session，token。服务器是怎么知道你这个登录的用户是哪个用户？"></a>说一下 cookies 和 session，token。服务器是怎么知道你这个登录的用户是哪个用户？</h2><ul><li>cookie 和 session 都是用来存储数据的，cookie 的数据存储在浏览器，session 的数据存储在服务器端，用户请求，服务器端生成 session 并返回 sessionid 给客户端，客户端把 sessionid 存储在 cookie 中，以后请求都会带上 sessionid</li><li>token 和 session 算是一类，都是用于服务器验证的。</li><li>服务器会通过用户请求携带的 sessionid 来识别用户</li></ul><h2 id="敏捷开发的特点"><a href="#敏捷开发的特点" class="headerlink" title="敏捷开发的特点"></a>敏捷开发的特点</h2><p>敏捷开发多用于小的团队，以用户为核心，利用短迭代方法来交付软件，开发的过程中更注重的是人员的交流。</p><h2 id="Selenium-中-等待方式有哪些，区别是什么？"><a href="#Selenium-中-等待方式有哪些，区别是什么？" class="headerlink" title="Selenium 中,等待方式有哪些，区别是什么？"></a>Selenium 中,等待方式有哪些，区别是什么？</h2><ul><li>sleep 休眠方法</li><li>隐式等待，driver.implicitly_wait(10) 隐性等待，最长等 10 秒</li><li>显示等待，WebDriverWait() 它是由 Webdirver 提供的等待方法</li></ul><h2 id="功能测试在-beta-版本对外上线的标准是什么"><a href="#功能测试在-beta-版本对外上线的标准是什么" class="headerlink" title="功能测试在 beta 版本对外上线的标准是什么"></a>功能测试在 beta 版本对外上线的标准是什么</h2><ul><li>测试用例全部跑完，并且 Bug 都已经关闭，然后业务验收后可以上线。</li></ul><h2 id="软件测试结束的标准"><a href="#软件测试结束的标准" class="headerlink" title="软件测试结束的标准"></a>软件测试结束的标准</h2><ul><li>测试用例全部跑完，并且 Bug 都已经关闭</li><li>性能指标达到要求</li><li>验收测试通过</li></ul><h2 id="有没有用过-django-框架？"><a href="#有没有用过-django-框架？" class="headerlink" title="有没有用过 django 框架？"></a>有没有用过 django 框架？</h2><h2 id="你知道深拷贝和浅拷贝的区别吗？"><a href="#你知道深拷贝和浅拷贝的区别吗？" class="headerlink" title="你知道深拷贝和浅拷贝的区别吗？"></a>你知道深拷贝和浅拷贝的区别吗？</h2><p>如果拷贝的对象里的元素只有值，没有引用，那浅拷贝和深拷贝没有差别，如果拷贝的对象里的元素包含引用，浅拷贝保存的是引用地址，对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值。而深拷贝则不同，它会将原对象里的引用也新创建一个。</p><h2 id="一个测试需要具备什么素质？"><a href="#一个测试需要具备什么素质？" class="headerlink" title="一个测试需要具备什么素质？"></a>一个测试需要具备什么素质？</h2><ul><li>五心（细心，专心，耐心，信心，责任心）</li><li>要相信任何软件都存在缺陷</li><li>需要具备专业的软件测试技能</li><li>具备一定的逻辑分析能力</li><li>具备团队合作精神</li><li>具备较好的沟通能力</li><li>实事求是</li><li>具备较好的学习能力</li><li>具备一定的编程能力</li><li>要有原则</li><li>不断总结经验与教训</li><li>无论缺陷大小都要上报</li><li>遇到不可重现的bug也要报告</li></ul><h3 id="保持怀疑"><a href="#保持怀疑" class="headerlink" title="保持怀疑"></a>保持怀疑</h3><p>对产品的质量持有一颗敢于怀疑的心，质量不是开发人员说”我做完了而且也测过了”就可以保证的。直到你测完最后一轮，最后一个用例之前，你都应该对产品的质量持怀疑态度。这个态度是混口饭吃的最基本技能。</p><h3 id="永不妥协"><a href="#永不妥协" class="headerlink" title="永不妥协"></a>永不妥协</h3><p>不要对产品质量妥协，哪怕开发口口声声说这个问题不好改，改不了，一改就要延期之类的话。妥协意味着你成功的把质量不好这口黑锅华丽的背在了自己的身上。</p><h3 id="让用户满意"><a href="#让用户满意" class="headerlink" title="让用户满意"></a>让用户满意</h3><p>产品或项目成功的标志之一是能够让用户满意，很显然用户是不会对一个bug频出的系统／产品满意的。</p><h3 id="从用户角度思考"><a href="#从用户角度思考" class="headerlink" title="从用户角度思考"></a>从用户角度思考</h3><p>很多测试同学不知道测试用例应该怎么去写，不知道怎么写才能写得出比较健全的用例。当你在苦恼用例从哪里来的时候，不妨试试下面两个办法从用户角度去思考，如果你是一个特定的用户（年龄，身份，职业）你应该会怎么使用这个产品从场景的角度去思考，在哪些场景下会使用到这个产品写不出用例可能就意味着你对产品的功能不够熟悉，不如让熟悉这个产品的同事给你介绍一下主要功能</p><h3 id="分清主次"><a href="#分清主次" class="headerlink" title="分清主次"></a>分清主次</h3><p>要分清楚任务的优先级，优先级高的先做，依此类推。在没有分清优先级的情况下不要盲目的开始测试。</p><h3 id="从不承诺100-的覆盖率"><a href="#从不承诺100-的覆盖率" class="headerlink" title="从不承诺100%的覆盖率"></a>从不承诺100%的覆盖率</h3><p>不要把话说满，这个中国人都很理解。不要保证太高的目标，给自己留点后路。</p><h3 id="倾听建议"><a href="#倾听建议" class="headerlink" title="倾听建议"></a>倾听建议</h3><p>别人的建议有些是金玉良言，有些则可以忽略不计。做测试的时候你不是一个人在战斗，多听听别的的有效建议是没有坏处的。</p><h3 id="尽早开始"><a href="#尽早开始" class="headerlink" title="尽早开始"></a>尽早开始</h3><p>尽早开始重要的模块的测试工作。因为问题发现的越早解决的成本就越低。另外早点开始测试重要的模块或功能可以尽可能多的增加测试时间，拿时间换质量一般来说是效果的。这个建议的另一个说法就是想办法让重要的模块可以尽早的开始测试。</p><h3 id="确定并管理风险"><a href="#确定并管理风险" class="headerlink" title="确定并管理风险"></a>确定并管理风险</h3><p>在做项目测试的时候，一个好的测试同学需要有发现项目质量上可能出现的风险的能力。另外当发现了项目风险的时候，我们还需要能够将风险管理起来，让风险可以被控制，可以被解决。</p><h3 id="做市场调研"><a href="#做市场调研" class="headerlink" title="做市场调研"></a>做市场调研</h3><p>看看友商的产品做的怎么样，有什么好的地方，有什么不好地方。好的地方我们的产品可以学习，不好的地方我们可以预防和改进。这是站在产品人员的角度去看待自己的项目或产品，因为好的测试在某些时候需要具备好的产品人员的素质。</p><h3 id="培养BA技能"><a href="#培养BA技能" class="headerlink" title="培养BA技能"></a>培养BA技能</h3><p>BA就是业务分析师的意思，在某些项目里，这类同学被称为产品狗。这要求测试人员有分析需求的能力，哪些需求是真需求，哪些需求是伪需求。真需求就玩命的测，伪需求在时间允许的情况下尽量的测。这也是产品视角，这也是为什么有很多测试同学转去做产品的原因。</p><h3 id="不要忘了异常情况"><a href="#不要忘了异常情况" class="headerlink" title="不要忘了异常情况"></a>不要忘了异常情况</h3><p>只测试正常的流程往往是不太够的，一些异常的情况我们也需要进行测试。另外不出意外的话异常情况的测试用例数量是要多于正常情况的。测试异常情况有助于我们发现bug，也有助于我们换个角度看待产品和项目的业务行为。</p><h3 id="Be-a-Good-Judge-of-Your-Product"><a href="#Be-a-Good-Judge-of-Your-Product" class="headerlink" title="Be a Good Judge of Your Product"></a>Be a Good Judge of Your Product</h3><p>做那个对项目/产品最有发言权的人。</p><h3 id="学会交涉"><a href="#学会交涉" class="headerlink" title="学会交涉"></a>学会交涉</h3><p>在保证项目质量的前提下我们要尽可能多的通过交涉和协商保障自己的利益。交涉意味着在某些情况下我们需要做出让步，退一步海阔天空，但前提是，退的这一步不影响项目或产品的质量。</p><h3 id="停止指责"><a href="#停止指责" class="headerlink" title="停止指责"></a>停止指责</h3><p>出问题的时候第一要务是先把问题解决掉，而不是指责相关责任人。</p><h3 id="做一个好的观察者"><a href="#做一个好的观察者" class="headerlink" title="做一个好的观察者"></a>做一个好的观察者</h3><p>观察项目，观察开发的流程，观察测试的流程，发现问题，提出问题，引导团队去解决问题。</p><h2 id="python-主要数据类型有哪些？"><a href="#python-主要数据类型有哪些？" class="headerlink" title="python 主要数据类型有哪些？"></a>python 主要数据类型有哪些？</h2><ul><li>数字：int、float、bool、complex</li><li>字符串：str</li><li>列表：list，用[]</li><li>元组：tuple，用()，就相当于不可修改的list</li><li>集合：set，用{}</li><li>字典：dict，用{key: value}</li></ul><h2 id="Linux-面试"><a href="#Linux-面试" class="headerlink" title="Linux 面试"></a>Linux 面试</h2><h3 id="你说一些-linux-命令，chmod-命令是干嘛的？怎么查看端口被占用？"><a href="#你说一些-linux-命令，chmod-命令是干嘛的？怎么查看端口被占用？" class="headerlink" title="你说一些 linux 命令，chmod 命令是干嘛的？怎么查看端口被占用？"></a>你说一些 linux 命令，chmod 命令是干嘛的？怎么查看端口被占用？</h3><ul><li><p>chmod 修改文件权限</p></li><li><p>查看某个进程的pid</p><pre><code>ps -ef | grep xxx(某个进程)</code></pre></li><li><p>查找被占用的端口<br>```<br>netstat -tln<br>netstat -tln | grep 8083<br>netstat -lnp | grep 8083 </p></li></ul><pre><code>- 查看端口属于哪个程序？端口被哪个进程占用</code></pre><p>  lsof -i :8083  </p><pre><code>- 杀掉占用端口的进程</code></pre><p>kill -9 进程id</p><pre><code></code></pre>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试理论</title>
    <link href="/alwaysblog/post/4261055596/"/>
    <url>/alwaysblog/post/4261055596/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是软件测试"><a href="#什么是软件测试" class="headerlink" title="什么是软件测试"></a>什么是软件测试</h2><p>在规定的条件下，对程序进行操作，从而发现错误，对软件质量进行评估的过程。</p><h2 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h2><p>以最少的人力、物力、时间找到软件的缺陷，并修改从而规避商业风险。</p><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>使用人工和自动手段来运行和测试某个系统的过程，目的在于检验是否满足了需求。</p><h2 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h2><ul><li>所有的测试都应该追朔到用户需求</li><li>尽早和不断的测试</li><li>测试工作都应该由独立的专业的软件测试机构来完成</li><li>pareto 原则，测试发现的错误中 80% 很可能起源于 20% 的模块中（20% 指的是应用中出现的新模块，开发人员第一次开发，故会出现较多错误）</li><li>设计测试用例时，应该考虑各种情况<ul><li>测试用例： 测什么？怎么测？</li></ul></li><li><strong>对测试出的错误结果一定要有一个确认的过程（描述缺陷报告）</strong><ul><li>书写错误文档</li></ul></li><li>指定严格的测试计划</li><li><strong>完全测试是不可能的，测试需要终止</strong></li><li>注意回归测试的的关联性<ul><li>回归测试：指开发人员修改了旧代码后，我们需要重新进行测试，以确认修改没有有引入新的错误，或导致其他代码产生错误。</li></ul></li><li>妥善保存一切测试过程文档</li></ul><h2 id="软件产品质量模型（ISO-IEC-9126）"><a href="#软件产品质量模型（ISO-IEC-9126）" class="headerlink" title="软件产品质量模型（ISO / IEC 9126）"></a>软件产品质量模型（ISO / IEC 9126）</h2><ul><li>功能性：提供满足明确和隐含要求的功能的能力</li><li>可靠性：在特定条件下使用时，软件产品呢维持规定的性能级别能力<ul><li>设备最好不要出故障</li><li>社保出故障了，不要影响主要的功能和业务</li><li>如果影响了主要功能和业务，系统可以尽快定位并恢复</li></ul></li><li>易用性：易懂、易学、易用、漂亮好看（用户体验好）</li><li>效率：软件产品可提供适当的性能的能力，也就是产品的性能（单选、多选、全选）</li><li>可维持性：产品可以被修改的能力。可以增加功能，可以更新。</li><li>可移植性：跨越不同系统平台</li></ul><h2 id="软件质量模型保证（SQA）"><a href="#软件质量模型保证（SQA）" class="headerlink" title="软件质量模型保证（SQA）"></a>软件质量模型保证（SQA）</h2><p>[ 目的 ]</p><pre><code>使软件制作的过程对于领导层是可见的。</code></pre><p>[ 目标 ]</p><ul><li>保证工作是有计划进行的</li><li>客观的验证软件项目产品和工作是否遵循恰当的标准，步骤和需求。</li><li>保证工作及结果及时通知给相关人员</li><li>高管可以接触到项目内部</li><li>软件质量需要测试工作来保证</li></ul><p>[ QC（检验产品的质量）]</p><p>找出产品存在的问题，进行质量控制，向管理层反馈质量信息。</p><p>[ QA（审计产品过程的质量）]</p><p>来确认项目按照要求进行，审计的内容主要是过程； QA 则确保 QC 按照过程进行质量控制活动，按照过程将检查结果向管理层汇报。</p><h2 id="软件测试的基本流程"><a href="#软件测试的基本流程" class="headerlink" title="软件测试的基本流程"></a>软件测试的基本流程</h2><ul><li>需求分析</li><li>编写测试用例（测什么？怎么测？）</li><li>评审测试用例</li><li>搭建测试环境</li><li>等待开发提供测试包</li><li>部署测试包</li><li>冒烟测试（对软件主体的基本功能进行基本测试）</li><li>执行测试用例</li><li>BUG 跟踪处理（提交及回归 BUG）</li><li>N 轮之后符合需求</li><li>测试结束</li></ul><h2 id="测试用例编写"><a href="#测试用例编写" class="headerlink" title="测试用例编写"></a>测试用例编写</h2><h4 id="测试需求"><a href="#测试需求" class="headerlink" title="测试需求"></a>测试需求</h4><div align="center"><p><img src="https://ftp.bmp.ovh/imgs/2020/04/44d5789a21365530.png" alt="测试需求"></p></div><h4 id="测试要点和测试点"><a href="#测试要点和测试点" class="headerlink" title="测试要点和测试点"></a>测试要点和测试点</h4><div align="center"><p><img src="https://ftp.bmp.ovh/imgs/2020/04/4a83c3b61ceeafa8.png" alt="测试要点和测试点"></p></div><h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><div align="center"><p><img src="https://ftp.bmp.ovh/imgs/2020/05/0d7cbc216f388880.png" alt="V模型"></p></div><p><strong>开发和测试阶段划分比较清晰</strong></p><ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>单元测试（独立的模块测试）</li><li>集成测试（模块联调）</li><li>系统测试（整体流程）</li><li>验收测试（验证是否满足需求）</li></ul><p>[ 优点 ]</p><ul><li>包含底层测试（单元测试）和高层测试（系统测试）</li><li>阶段划分清晰，方便工作的整体把控</li></ul><p>[ 缺点 ]</p><ul><li>测试阶段比较靠后，之前的问题已经产生，修改不方便</li><li>V 模型就是瀑布模型的变种，如果需求发生变化必然返工</li></ul><h3 id="W-模型（双-V-模型）"><a href="#W-模型（双-V-模型）" class="headerlink" title="W 模型（双 V 模型）"></a>W 模型（双 V 模型）</h3><div align="center"><p><img src="https://ftp.bmp.ovh/imgs/2020/05/7d4ee17a2197ece6.png" alt="W 模型"></p></div><p><strong>开发一个 V, 测试一个 V，开发和测试并行</strong></p><ul><li>开发 V (需求分析、概要设计、详细设计、编码、集成、实施、交付)</li><li>测试 V (系统测试设计、集成测试设计、单元测试设计、单元测试、集成测试、系统测试、验收测试)</li></ul><p>[ 优点 ]</p><ul><li>开发伴随着测试并行，需求和设计一样要进行测试</li><li>尽早的介入测试，会更早的发现问题，降低修复成本</li><li>阶段依然明显，方便整体流程把控</li></ul><p>[ 缺点 ]</p><ul><li>代码依然在测试之前，不方便代码的测试工作</li><li>如果没有文档，根本无法进行 W 模型，对人员要求较高</li></ul><h2 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h2><div align="center"><p><img src="https://ftp.bmp.ovh/imgs/2020/05/c3f48210f76d2c81.png" alt="软件测试分类"></p></div><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="什么是系统测试"><a href="#什么是系统测试" class="headerlink" title="什么是系统测试"></a>什么是系统测试</h3><p>  系统测试是一个全面的测试，包括单元、集成测试，</p><h3 id="系统测试的方法是什么"><a href="#系统测试的方法是什么" class="headerlink" title="系统测试的方法是什么"></a>系统测试的方法是什么</h3><ul><li>功能测试<ul><li>概念：根据产品的需求说明书和测试需求列表，验证产品的功能实现是否符合产品的需求规格</li><li>考察特性： 功能是否有遗漏，功能是否准确</li><li>测试思路/步骤：<ol><li>确定功能需求列表</li><li>分析功能测试得出测试子项</li><li>根据测试子项分析</li><li>采用测试用例方法设计用例</li></ol></li><li>测试点： 根据产品的需求说明书和测试需求列表，验证产品的功能实现是否符合产品的需求规格，满足用户显性和隐形的需求</li></ul></li><li>性能测试<ul><li>概念：验证系统在不同的业务场景下的响应时间和资源利用率等性能指标是否符合预期的标准</li><li>测试思路： <ol><li>压力测试：调查系统在其资源超负荷的情况下的表现，尤其是这些对系统的处理时间有什么影响</li><li>容量测试：面向与数据。使系统承受超额的数据容量来发现它是否可以处理数据容量</li><li>负载测试：在一定负载的情况下系统的性能表现（不关注稳定性，也就是说不关注长时间运行，只是得到不同负载相关性能指标即可）</li></ol></li></ul></li><li>安全性测试: <ul><li>概念：用来验证集成在系统内的保护机制是否能够在实际的情况中不受到非法的侵入</li><li>测试点：<ol><li>权限管理（注册登录才可以查看、注册信息符合要求、密码后台加密）</li><li>信息保存（log、日志、cookie）</li><li>数据库（默认的用户名和密码）</li><li>协议(http协议)</li></ol></li><li>安全性测试策略：层层剥离法</li><li>工具：</li><li>书籍：白帽子讲 web 安全</li></ul></li><li>异常测试：<ul><li>概念：又叫系统容错和可恢复性测试</li><li>可靠性：指标</li><li>可靠性设计方法：<ol><li>避开错误（主动避开错误，针对可以预见的错误进行主动处理。试点：故意构测造无效数据、边界条件、压力测试） </li><li>容错技术（主动断电强制进入新的设备、构造数据库瘫痪、构造数据死锁、构造数据的不完整事物、构造出错的时间点：断网、短信号）</li></ol></li></ul></li><li>GUI 测试内容<ul><li>界面实现与界面设计的吻合情况</li><li>确认界面处理的正确性</li></ul></li><li>易用性测试</li><li>安装测试</li><li>配置测试</li><li>兼容测试</li></ul><h2 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h2><h3 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h3><p><strong>把无法穷举的数据分类书写</strong></p><ul><li>按需求写出有效等价类</li><li>按需求取反无效等价类</li><li>找到特殊情况的无效等价类（中文、英文、空格、空、符号等）</li></ul><p>[ 细节 ]</p><ul><li>输入长度</li><li>组成规则</li><li>输入类型</li><li>是否为空</li><li>是否去除空格</li><li>是否区分大小写</li></ul><h3 id="边界值测试"><a href="#边界值测试" class="headerlink" title="边界值测试"></a>边界值测试</h3><ul><li>找到测试数据的边界点进行测试，也就是有效等价类和无效等价类的边界点</li><li>一般情况下需要对边界值以及边界值两边的的值分别进行测试（如：0-100，需要测试 0， 100， -1，1，99，101）</li></ul><h3 id="因果图制作判定表"><a href="#因果图制作判定表" class="headerlink" title="因果图制作判定表"></a>因果图制作判定表</h3><ul><li>找到所有的输入条件和预期结果，把所有的输入条件和输出条件填写进去</li><li>得到初始表格，根据实际需求进行简化</li></ul><h3 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h3><ul><li>基本流：正确的业务流程</li><li>备选流：有问题的业务流程</li></ul><p>测试用例书写：需求文档的每一个需求</p><h3 id="流程法"><a href="#流程法" class="headerlink" title="流程法"></a>流程法</h3><p>测试用例必须包含所有的分支条件，每一个分支条件就是一条测试用例。</p><h3 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h3><ul><li>时间急，任务紧，测试时间少，考虑使用错误推断法，根据测试人员以往的项目经验进行设计</li><li>已经经过几轮测试后，可以使用错误推测法进行测试用例的补充</li></ul><h3 id="正交排列法"><a href="#正交排列法" class="headerlink" title="正交排列法"></a>正交排列法</h3><p>当要测试的内容，需要排列组合的情况非常多的时候，我们考虑使用科学的方法来减少测试用例的个数，即正交表。</p><p><strong>特点：均匀分散，齐整可比，所有的情况都应该被均匀的测试过一次</strong></p><ul><li>因素：控件的个数</li><li>水平：控件里面的可选项个数</li></ul><p>[ 步骤 ]</p><ul><li>先确定几因素，几水平</li><li>在“常用正交表”中找到合适的表格</li><li>复制找到的表格到自己的表格中</li><li>写一个对照表（所有的控件和对应的选项列出来）</li><li>把复制过来的表格和对照表实现映射关系</li></ul><p><strong>如果没有找到合适的正交表，选用多一些的正交表，把多余的内容删除</strong></p><h3 id="混合正交表"><a href="#混合正交表" class="headerlink" title="混合正交表"></a>混合正交表</h3><p>步骤：</p><ul><li><p>制作取值表</p></li><li><p>复制取值表的数据，放到文本文档中保存</p></li><li><p>把文本文档放在 allpairs.文件夹中</p></li><li><p>WIN+R 键进入 cmd 控制台</p></li><li><p>进入 allpairs 文件夹</p></li><li><p>在制台中入 allpairs 的文件路径如 F:allpairs/allpairs.exe test1.txt&gt;test2.txt(其中 test1 是你放进 allpairs 文件夹中的文件，test2 填你要生成的文件名)</p></li></ul><p>[ 获取方式 ]</p><ul><li><p>链接: <a href="https://pan.baidu.com/s/1yQ7lrZSeR6lnvyYeXLzEdw?pwd=tap5" rel="external nofollow noreferrer">https://pan.baidu.com/s/1yQ7lrZSeR6lnvyYeXLzEdw?pwd=tap5</a> </p></li><li><p>提取码: tap5 </p></li></ul><h2 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h2><h3 id="测试用例设计综合策略"><a href="#测试用例设计综合策略" class="headerlink" title="测试用例设计综合策略"></a>测试用例设计综合策略</h3><ol><li><p>在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。</p></li><li><p>必要时用等价类划分方法补充一些测试用例。</p></li><li><p>用错误推测法再追加一些测试用例。</p></li><li><p>对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。</p></li><li><p>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。 </p></li></ol><h3 id="测试用例的设计步骤"><a href="#测试用例的设计步骤" class="headerlink" title="测试用例的设计步骤"></a>测试用例的设计步骤</h3><ol><li><p>构造根据设计规格得出的基本功能测试用例。</p></li><li><p>边界值测试用例</p></li><li><p>状态转换测试用例。</p></li><li><p>错误猜测测试用例。</p></li><li><p>异常测试用例。 </p></li></ol><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h3 id="缺陷状态"><a href="#缺陷状态" class="headerlink" title="缺陷状态"></a>缺陷状态</h3><table><thead><tr><th>编号</th><th>缺陷状态</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>提交</td><td>已提交的缺陷</td></tr><tr><td>2</td><td>打开</td><td>确认提交的缺陷，等待处理</td></tr><tr><td>3</td><td>拒绝</td><td>拒绝提交的缺陷，不需要修复或不是缺陷、重复缺陷、无法重现</td></tr><tr><td>4</td><td>修复</td><td>缺陷被修复（开发人员自认为修改对了）</td></tr><tr><td>5</td><td>关闭</td><td>确认修复的缺陷，将其关闭（测试人员进行回归复测，确认已经没问题）</td></tr><tr><td>6</td><td>推迟</td><td>可在以后解决，但要确定修复日期和版本</td></tr></tbody></table><p>[ 禅道 ]</p><ul><li>激活</li><li>已解决</li><li>已关闭</li></ul><h3 id="缺陷程度划分"><a href="#缺陷程度划分" class="headerlink" title="缺陷程度划分"></a>缺陷程度划分</h3><ol><li>表面错误</li><li>影响独立模块、断断续续的问题、特定条件下发生、与产品要求不一致。</li><li>功能点没有实现、数据丢失</li><li>影响了系统或者出现了严重的计算错误</li></ol><h3 id="缺陷的优先级"><a href="#缺陷的优先级" class="headerlink" title="缺陷的优先级"></a>缺陷的优先级</h3><table><thead><tr><th>优先级别</th><th>描述</th></tr></thead><tbody><tr><td>5-urgent</td><td>最高优先级 在这个错误影响下，系统几乎不可用</td></tr><tr><td>4-veryHigh</td><td>高优先级 错误对系统的功能产生严重的影响</td></tr><tr><td>3-high</td><td>中优先级 错误会制约开发和测试的活动进行，如果先前没有修复他，那么需要在发布前修复他</td></tr><tr><td>2-medium</td><td>低优先级 不会延迟发布，但是会在以后修正这个错误</td></tr><tr><td>1-low</td><td>最低优先级 时间和资源允许时修正</td></tr></tbody></table><p><strong>优先级和严重程度不是绝对的正比关系</strong></p><h3 id="缺陷类型"><a href="#缺陷类型" class="headerlink" title="缺陷类型"></a>缺陷类型</h3><ul><li>系统缺陷</li><li>数据缺陷</li><li>数据库缺陷</li><li>接口缺陷</li><li>功能缺陷</li><li>安全性缺陷</li><li>兼容性缺陷</li><li>性能缺陷</li><li>界面缺陷（删除操作未给出提示）</li><li>建议（功能建议、操作建议）</li></ul><h3 id="缺陷报告注意事项"><a href="#缺陷报告注意事项" class="headerlink" title="缺陷报告注意事项"></a>缺陷报告注意事项</h3><ul><li>尽量确保缺陷可以重现</li><li>简洁、准确、完整</li><li>一个缺陷一个报告</li><li>复现缺陷的步骤清晰（一个编号一个步骤）</li><li>描述结果和期望结果（结果就是 BUG 出现结果）</li><li>使用术语描述问题</li></ul><h3 id="缺陷统计"><a href="#缺陷统计" class="headerlink" title="缺陷统计"></a>缺陷统计</h3><ul><li>对软件问题的功能域分布进行分析，找出系统的薄弱环节<ul><li>要详细采集每个功能模块或系统构件的缺陷数据，并按功能、错误类型、严重程度等分类</li><li>二八定理：80% 的软件问题总发生在大约 20% 的功能模块中</li></ul></li><li>对缺陷的注入阶段进行分析，并于历史数据相比较</li><li>应对软件缺陷类型进行分析，以便针对各自特点，先修复严重缺陷</li><li>动态采集每个测试周期中发现的缺陷数，并有效的控制缺陷的修复率</li><li>密切观察缺陷的状态，并及时跟踪其状态的变化，以检查测试和开发人员的工作情况</li></ul><h2 id="SVN-使用"><a href="#SVN-使用" class="headerlink" title="SVN 使用"></a>SVN 使用</h2><ul><li>创建版本库</li><li>检出 （获取版本库最新版本，只有检出操作后才能提交更新操作）</li><li>提交（把此文件夹中的内容提交到版本库）</li><li>更新（把最新的版本库中的内容，更新到此文件夹中）</li></ul><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><h3 id="接口优点"><a href="#接口优点" class="headerlink" title="接口优点"></a>接口优点</h3><ul><li>责任划分清晰</li><li>缩短研发周期</li><li>可扩展性强</li></ul><h3 id="接口测试流程"><a href="#接口测试流程" class="headerlink" title="接口测试流程"></a>接口测试流程</h3><ul><li>接口的功能测试（先保证接口是正确的）</li><li>测试接口的数据（传递一些特殊的数据，保证接口没有问题）</li><li>自动化测试脚本的编辑</li><li>接口的性能、压力测试</li></ul><blockquote><ul><li>HTTP: 超文本传输协议，浏览器和服务器之间通信的规则</li><li>URL: 统一资源定位符，协议://主机地址/路径</li><li>GET: 提交的数据显示在地址栏，不安全，提交的数据量有限制，不重要的数据使用 GET</li><li>POST: 隐式提交数据，更安全，没有数据量大小的限制，重要数据使用 POST</li></ul></blockquote><h3 id="restful-风格（API-文档规则，非强制要求，软要求）"><a href="#restful-风格（API-文档规则，非强制要求，软要求）" class="headerlink" title="restful 风格（API 文档规则，非强制要求，软要求）"></a>restful 风格（API 文档规则，非强制要求，软要求）</h3><ul><li>查<ul><li>方法: GET</li><li>响应码: 200 + 查询数据</li></ul></li><li>增<ul><li>方法: POST</li><li>响应码: 201 + 新增的数据</li></ul></li><li>改<ul><li>方法: PUT</li><li>响应码: 200/201 + 修改后的数据</li></ul></li><li>删<ul><li>方法: DELETE</li><li>响应码: 204 + 无</li></ul></li></ul><h3 id="接口请求的四大要素"><a href="#接口请求的四大要素" class="headerlink" title="接口请求的四大要素"></a>接口请求的四大要素</h3><ul><li>接口 URL 地址</li><li>请求方法</li><li>请求头</li><li>请求参数</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 3 多列布局</title>
    <link href="/alwaysblog/post/2560017432/"/>
    <url>/alwaysblog/post/2560017432/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS-3-多列布局"><a href="#CSS-3-多列布局" class="headerlink" title="CSS 3 多列布局"></a>CSS 3 多列布局</h3><p>[ column 属性 ]</p><p>——column 属性是一个简写属性  包含 column-count 属性 定义列的数量 和 column-width 属性定义列的宽度</p><span id="more"></span><ul><li> column-count 属性 用于设置列的数量或允许的最大列数</li></ul><ul><li>auto: 默认值，用于表示列的数量由其他 CSS 属性绝对决定</li><li>number: 必须是正整数，用于表示定义列的数量</li></ul><ul><li>column-width 属性 用于设置列的宽度或列的最小宽度<ul><li>auto: 默认值，用于表示列的宽度由其他 CSS 属性绝对决定</li><li>length: 必须是正整数，用于表示定义列的宽度</li></ul></li></ul><pre><code class="html">&lt;style&gt;    /*      *       *       *     */    * &#123;       margin: 0;       padding: 0;     &#125;    .parent &#123;        background-color: #eee;        /* column-count: 6; */        /* column-width: 200px; */        /* 简写属性 */        columns: 6 auto;    &#125;    .column1,    .column2,    .column3,    .column5,    .column6 &#123;        height: 300px;    &#125;    .column2 &#123;        background-color: #ff66ff;    &#125;    .column3 &#123;        background-color: #00ffff;    &#125;    .column1 &#123;        background-color: #ffff00;    &#125;    .column5 &#123;        background-color: #ff0000;    &#125;    .column6 &#123;        background-color: #00ff00;    &#125;    &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;column1&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;column2&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;column3&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;column6&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;column5&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;column6&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>[ 列的间距 ]</p><ul><li><p>column-gap 属性用于设置列于列之间的间距，该属性需要为多列显示时的元素设置</p><ul><li><p>normal:  用于表示使用浏览器定义列的默认间距，默认值 1em</p></li><li><p>length: 必须是正整数，用于表示定义列之间的间距</p><pre><code class="html">&lt;style&gt; .parent &#123;    background-color: #eee;    /* column-count: 6; */    /* column-width: 200px; */    /* 简写属性 */    columns: 5 auto;    column-gap: 20px;&#125;&lt;/style&gt;</code></pre><p>[列的边框 column-rule ]</p></li></ul></li></ul><p>—— column-rule 属性用于定义列于列之间的边框，其中包括边框宽度、边框颜色、边框样式。</p><ul><li>column-rule-width: 列于列之间的边框宽度</li><li>column-rule-color: 列于列之间的边框颜色</li><li>column-rule-style: 列于列之间的边框样式   </li></ul><pre><code class="html">&lt;style&gt;   .parent &#123;       background-color: #eee;       /* column-count: 6; */       /* column-width: 200px; */       /* 简写属性 */       columns: 5 auto;       column-gap: 20px;       /* column-rule-width: 5px;       column-rule-color: #ff0000;       column-rule-style: double; */       /* 简写属性 */       column-rule: 5px #ff0000 double;   &#125;&lt;/style&gt;</code></pre><p> [ 横跨多列 ]</p><ul><li>column-span 属性 用于定义一个列元素是否跨列<ul><li>none：表示元素不跨列</li><li>all: 表示元素跨所有列 </li></ul></li></ul><pre><code class="html">&lt;style&gt;   .column6 &#123;       background-color: #00ff00;       column-span: all;   &#125;&lt;/style&gt;</code></pre><p> [ 列的填充 ]</p><ul><li><p>column-fill 属性用于定义列的高度由内容决定，还是同一高度</p><ul><li><p>auto: 默认值，列的高度由内容绝对</p></li><li><p>balance: 列的高度根据内容最多的一列的高度为准</p><pre><code class="html">&lt;style&gt;.column6,.column7, .column8,.column9 &#123;    /* 浏览器兼容不好 包括chrome浏览器 */    column-fill: balance;&#125;&lt;/style&gt;   &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;column6&quot;&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Ipsum eum dolorum ad quod velit. Corporis inventore alias nostrum dignissimos nihil saepe harum vitae, sint, id voluptate, reprehenderit officiis magnam repellat?&lt;/div&gt;        &lt;div class=&quot;column7&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Tenetur iure dolorum deleniti soluta ipsum at ratione magni recusandae, sapiente necessitatibus, expedita nobis, animi corrupti exercitationem delectus ullam unde sed autem.&lt;/div&gt;        &lt;div class=&quot;column8&quot;&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Eius placeat blanditiis harum? Eum, sit corporis illo maxime, nemo excepturi nisi eveniet, error quis ex cum ut nulla sunt aut saepe?            Lorem ipsum dolor sit amet consectetur, adipisicing elit. Facilis debitis officia distinctio cupiditate tempora! Debitis corrupti omnis rerum voluptates laboriosam hic alias repellat nostrum, expedita rem perspiciatis totam maxime labore!        &lt;/div&gt;        &lt;div class=&quot;column9&quot;&gt;Lorem ipsum dolor, sit amet consectetur adipisicing elit. Laborum, earum. Nobis illo maxime necessitatibus voluptatibus quam nemo blanditiis impedit perferendis, porro delectus eligendi laboriosam voluptate adipisci, culpa vitae accusantium nesciunt.&lt;/div&gt;    &lt;/div&gt;</code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主流 CSS 布局(水平居中、垂直居中、居中 )</title>
    <link href="/alwaysblog/post/1679852539/"/>
    <url>/alwaysblog/post/1679852539/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是布局"><a href="#什么是布局" class="headerlink" title="什么是布局"></a>什么是布局</h3><ul><li>html 页面的整体结构或骨架</li><li>布局不是某个技术内容 而是一种设计思想</li></ul><span id="more"></span><p>[ 布局方式 ]</p><ul><li>水平居中布局</li><li>垂直居中布局</li><li>居中布局（ 水平 + 垂直 ）</li></ul><h3 id="什么是水平居中布局"><a href="#什么是水平居中布局" class="headerlink" title="什么是水平居中布局"></a>什么是水平居中布局</h3><p>水平居中布局 元素相对于页面/元素相对于父元素水平居中<br>[ 实现方式 ]</p><ul><li>inline-block + text-align 属性配合使用</li></ul><p><strong>注：[优点] 浏览器兼容性比较好  [缺点] text-align 属性具有继承性 导致子级元素的文本居中显示</strong><br>**解决方法：在子级元素重新设置 text-align 属性覆盖掉父级元素的 text-align 属性  **</p><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        width: 100%;        height: 200px;        background-color: #00ffff;        /* 方法一： inline-block + text-align 属性配合使用  为父元素 添加 text-align 属性  为子元素添加 display 属性           - text-align 属性 为文本内容设置对其方式             + left: 左对齐              + center: 居中对齐             + right: 右对齐           */        text-align: center;    &#125;    .child &#123;        width: 300px;        height: 200px;        background-color: #ff0000;        /* display 属性:           - block: 块级元素           - inline: 内联元素 (text-align 有效)             + width 和 height 属性无效           - inline-block: 行内块元素 (块级 + 内联 )         */        display: inline-block;    &#125;&lt;/style&gt;&lt;body&gt;&lt;!-- 居中布局 --&gt;&lt;!-- 方法一： inline-block + text-align 属性配合使用 --&gt;&lt;div class=&quot;parent&quot;&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><ul><li>table + margin 属性配合使用<br><strong>注：[优点] 只需要对子级元素进行设置就可以实现水平居中  [缺点] 如果子级元素脱离文档流，导致 margin 属性失效</strong><br><strong>解决方法：考虑第一种或第三种解决方案</strong></li></ul><p>[ 拓展 ]  CSS 中使元素脱离文档流的方式</p><ul><li>将元素设置浮动 float</li><li>将元素设置为绝对定位 position: absolute</li><li>将元素设置为固定定位 position: fixed</li></ul><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        width: 100%;        height: 200px;        background-color: #00ffff;    &#125;    .child &#123;        width: 300px;        height: 200px;        background-color: #ff0000;        /* 方法二： gtable + margin 属性配合使用 */        /* display的值 为 table 或 block */        display: table;        /* margin 属性： 外边距           - 一个值： 上下左右           - 两个值： 上下，左右             + auto 根据浏览器自动分配               - 三个值： 上，左右，下            - 四个值： 上，右，下，左         */        margin: 0 auto;    &#125;&lt;/style&gt;</code></pre><ul><li>absolute + transform 属性配合使用</li></ul><p><strong>注：[优点] 无论父级元素是否脱离文档流，不影响子级元素水平居中的效果  [缺点]  transform 属性是 CSS 3 中新增的属性 浏览器支持情况不好</strong><br>**解决方法：考虑第一种或第二种解决方案 **</p><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        width: 100%;        height: 200px;        background-color: #00ffff;        /* 相对定位 */        position: relative;    &#125;    .child &#123;        width: 300px;        height: 200px;        background-color: #ff0000;        /* 当把当前元素设置为绝对定位以后        - 如果父级元素没有设置定位，当前元素是相对于页面定位的        - 如果父级元素设置了定位，当前元素是相对于父级元素定位的         */        position: absolute;        left: 50%;        /* 水平方向平移 */        transform: translateX(-50%);        /* margin-left: -50%; */    &#125;&lt;/style&gt;</code></pre><ul><li>… …</li></ul><h3 id="什么是垂直居中布局"><a href="#什么是垂直居中布局" class="headerlink" title="什么是垂直居中布局"></a>什么是垂直居中布局</h3><p>垂直居中布局 ：当前元素相对于页面/父元素垂直方向是居中显示的<br>[ 实现方式 ]</p><ul><li>table-cell + vertical-align 属性配合使用<br><strong>注：[优点] 浏览器的兼容性比较好  [缺点]  vertical-align 属性 具有继承性 导致子级元素的文本居中显示</strong><br>**如果父级元素中包含除子级元素以外的文本内容，此方法不适用 **</li></ul><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        /*方法一： table-cell + vertical-align 属性配合使用 */        width: 200px;        height: 600px;        background-color: #00ffff;        /* display 属性：           - table: 设置当前元素为&lt;table&gt;元素           - table-cell：设置当前元素为&lt;td&gt;元素  单元格           - 设置完成以后 作为子级元素的div就相当于单元格中的内容了，设置对齐方式即可                 */        display: table-cell;        /*             vertical-align 属性: 用于设置文本内容的垂直方向的定对齐方式            - top： 顶部对齐            - middle: 居中对齐            - bottom: 底部对齐          */        vertical-align: middle;    &#125;    .child &#123;        width: 200px;        height: 300px;        background-color: #ff0000;    &#125;&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><ul><li>absolute + transform 属性配合使用<br><strong>注：[优点] 无论父级元素是否脱离文档流，不影响子级元素的垂直居中的效果  [缺点]  transform 属性是 CSS 3 中新增的属性 浏览器支持情况不好</strong><br>**解决方法：考虑第一种解决方案 **</li></ul><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        width: 200px;        height: 600px;        background-color: #00ffff;        position: relative;    &#125;    /* 方法二： absolute + transform 属性配合使用 */    .child &#123;        width: 200px;        height: 300px;        background-color: #ff0000;        position: absolute;        top: 50%;        /* 垂直方向 */        transform: translateY(-50%);    &#125;&lt;/style&gt;</code></pre><h3 id="什么是居中布局"><a href="#什么是居中布局" class="headerlink" title="什么是居中布局"></a>什么是居中布局</h3><p>居中布局：（ 水平 + 垂直 ）居中<br>[ 实现方式 ]</p><ul><li>display:block + margin 属性实现水平方向居中，table-cell + vertical-align 属性实现垂直方向居中<br><strong>注：[优点] 浏览器兼容性比较好   [缺点] 父元素与子元素都需要增加代码</strong></li></ul><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        width: 1000px;        height: 600px;        background-color: #00ffff;        /* 实现垂直居中  */        /* &lt;td&gt; */        display: table-cell;        vertical-align: middle;    &#125;    .child &#123;        width: 200px;        height: 300px;        background-color: #ff0000;        /* 实现水居中 */        /* &lt;table&gt; */        /* display: table; */        display: block;        margin: 0 auto;    &#125;&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><ul><li>absolute + transform 属性实现水平和垂直方向的居中<br><strong>注：[优点] 无论父级元素是否脱离文档流，不影响子级元素的垂直居中的效果，不考虑浏览器兼容性，优于第一中方案  [缺点]  transform 属性是 CSS 3 中新增的属性 浏览器支持情况不好同时子父元素都增加了代码</strong></li></ul><pre><code class="html">&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        width: 1000px;        height: 600px;        background-color: #00ffff;        /* 相对定位 不脱离文档流*/        position: relative;    &#125;    .child &#123;        width: 200px;        height: 300px;        background-color: #ff0000;        /* 绝对定位 ———— 子绝父相 */        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        /* transform: translateX(-50%);        transform: translateY(-50%); */    &#125;&lt;/style&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全屏布局</title>
    <link href="/alwaysblog/post/635713354/"/>
    <url>/alwaysblog/post/635713354/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是全屏布局？"><a href="#什么是全屏布局？" class="headerlink" title="什么是全屏布局？"></a>什么是全屏布局？</h3><p>—— HTML页面铺满整个浏览器串口窗口，并且没有横竖滚动条，而且可以跟随浏览器窗口的大小变化而变化。</p><span id="more"></span><p><img src="https://cdn.nlark.com/yuque/0/2020/png/518310/1585465562542-153aa1a9-15a9-49fd-b0e4-da921a11a670.png"></p><pre><code class="html">&lt;style&gt;    /*      * .content .right &#123;        height: 1000px;        background-color: rgb(243, 239, 12);        margin-left: 300px;        &#125;     *  此元素的高度可以不用设置，由内容高度撑开。     *     */    html,body&#123;       margin: 0;       padding: 0;        /* 避免全屏出现滚动条*/       overflow: hidden;    &#125;    header &#123;        height: 100px;        background-color: #eee;        position: fixed;        top: 0;        left: 0;        right: 0;    &#125;    .content &#123;        /* 提供滚动条 */        overflow: auto;        background-color: rgb(14, 197, 221);        position: fixed;        left: 0;        right: 0;        top: 100px;        bottom: 100px;    &#125;    .content .left &#123;        width: 300px;        height: 100%;        background-color: rgb(247, 54, 54);        position: fixed;        left: 0;        top: 100px;        bottom: 100px;    &#125;    .content .right &#123;        height: 1000px;        background-color: rgb(243, 239, 12);        margin-left: 300px;    &#125;    footer &#123;        height: 100px;        background-color: rgb(39, 38, 38);        position:fixed;        bottom: 0;        left: 0;        right: 0;    &#125;    &lt;/style&gt;&lt;body&gt;    &lt;header&gt;&lt;/header&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圣杯布局和双飞翼布局</title>
    <link href="/alwaysblog/post/1718216264/"/>
    <url>/alwaysblog/post/1718216264/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是圣杯布局"><a href="#什么是圣杯布局" class="headerlink" title="什么是圣杯布局"></a>什么是圣杯布局</h3><ul><li>布局效果类似于圣杯而得名，也叫做三行三列布局。</li><li>定宽 — 自适应 — 定宽<span id="more"></span><img src="https://cdn.nlark.com/yuque/0/2020/png/518310/1585465022554-4c8f3ae6-2497-40a8-a62b-436225a96465.png" alt="圣杯布局"></li></ul><p>[根据两列布局实现 定宽 — 自适应 — 定宽 布局方式]</p><pre><code class="html">   &lt;style&gt;    /* 改变了结构顺序，搜索引擎抓取主要内容变为最后     * 结构不同，解决方案也会不同       *      */    * &#123;       margin: 0;       padding: 0;     &#125;    .header,    .footer &#123;        height: 100px;        background-color: #000;    &#125;    .parent &#123;        background-color: #eee;        padding: 10px;     &#125;    .left,    .center,     .right &#123;        height: 300px;    &#125;    .left,    .right &#123;        width: 300px;    &#125;    .left &#123;        width: 300px;        background-color: #00ffff;        float: left;    &#125;    .center &#123;        background-color: #ffff00;        margin-left: 300px;        margin-right: 300px;    &#125;    .right &#123;        background-color: #ff0000;        float: right;    &#125;    /* 中间自适应部分没有浮动，右边元素浮动，在兄弟元素中，前边元素没有浮动，后边的元素浮动，浮动的元素不允许超过前边的元素，依旧垂直方向排列，把right的结构位置调到前面*/    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt; 左： 定宽&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右：自适应&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt; 中：定宽 &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>[ 圣杯布局的实现 ]</p><pre><code class="html">    &lt;style&gt;      /* 改变了结构顺序，搜索引擎抓取主要内容变为最后     * 结构不同，解决方案也会不同       * 根据问题，把center调至最前，但是需要其他方法解决，即给三个div添加父元素      */    * &#123;       margin: 0;       padding: 0;     &#125;    .header,    .footer &#123;        height: 100px;        background-color: #000;    &#125;    .parent &#123;        background-color: #eee;        /* 解决父级元素高度塌陷 */        height: 300px;        /* 对应 left 的宽度 */        margin-left: 300px;        /* 对应 right 的宽度  */        margin-right: 300px;    &#125;    .left,    .center,     .right &#123;        height: 300px;        /* 使三个div 浮动 */        float: left;    &#125;    .left,    .right &#123;        width: 300px;    &#125;    .left &#123;        background-color: #00ffff;        /* 将当前元素从当前行移动到上一行同一个位置*/        margin-left: -100%;        /* 将当前元素移动到理想位置 */        position: relative;        left: -300px;    &#125;    .center &#123;        width: 100%;        background-color: #ffff00;    &#125;    .right &#123;        background-color: #ff0000;        margin-left: -300px;        position: relative;        right: -300px;    &#125;    &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;center&quot;&gt; 中：定宽 &lt;/div&gt;        &lt;div class=&quot;left&quot;&gt; 左： 定宽&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右：自适应&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;     </code></pre><h3 id="什么是双飞翼布局"><a href="#什么是双飞翼布局" class="headerlink" title="什么是双飞翼布局"></a>什么是双飞翼布局</h3><p>—— 最早由淘宝团队提出，是针对圣杯布局的局部优化解决方案，主要优化了圣杯布局中开启定位的问题。</p><p>[ 双飞翼布局的实现 ]</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;双飞翼布局&lt;/title&gt;    &lt;style&gt;        /*          *            *         */    * &#123;       margin: 0;       padding: 0;     &#125;    .header,    .footer &#123;        height: 100px;        background-color: #000;    &#125;    .parent &#123;        height: 300px;        background-color: #eee;    &#125;    .left &#123;        width: 300px;        height: 300px;        background-color: #00ffff;        float: left;        margin-left: -100%;    &#125;    .center &#123;        width: 100%;        height: 300px;        background-color: #ffff00;        float: left;    &#125;    .right &#123;        width: 300px;        height: 300px;        background-color: #ff0000;        float: left;        margin-left: -300px;    &#125;    .inner &#123;        height: 300px;        background-color: #ff66ff;        margin-left: 300px;        margin-right: 300px;    &#125;    &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;center&quot;&gt;            &lt;div class=&quot;inner&quot;&gt;中：定宽&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;left&quot;&gt; 左： 定宽&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右：自适应&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多列布局</title>
    <link href="/alwaysblog/post/3225661351/"/>
    <url>/alwaysblog/post/3225661351/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是多列布局"><a href="#什么是多列布局" class="headerlink" title="什么是多列布局"></a>什么是多列布局</h3><p>——几个元素呈现水平方式排列的效果</p><span id="more"></span><p>[ 从元素分类角度 ]</p><ul><li>块级元素  默认垂直排列    设置浮动实现水平方式排列</li><li>内联元素  默认水平方式排列</li><li>行内块元素  默认水平方式排列</li></ul><p>[ 多列布局分类 ]</p><ul><li>两列布局   一列定宽，另外一列宽度自适应</li><li>三列布局<ul><li>两列定宽且相邻，另外一列宽度自适应</li><li>两边定宽 中间自适应，即圣杯布局和双飞翼布局 先有圣杯布局然后演变出双飞翼布局</li></ul></li><li>等分布局  每一列宽度相同</li><li>等高布局  每一列高度相同</li><li>CSS 3 三列布局 </li></ul><h3 id="什么是两列布局"><a href="#什么是两列布局" class="headerlink" title="什么是两列布局"></a>什么是两列布局</h3><p>—— 左列确定宽度，右列自动填满剩余空间</p><h3 id="两列布局的实现"><a href="#两列布局的实现" class="headerlink" title="两列布局的实现"></a>两列布局的实现</h3><h4 id="float-margin-属性实现"><a href="#float-margin-属性实现" class="headerlink" title="float + margin 属性实现"></a>float + margin 属性实现</h4><p>**  此方案的优缺点<br>优点：实现方式简单<br>缺点：</p><ol><li>自适应元素 margin 属性值必须与定宽元素的width 值保持一致  高耦合</li><li>定宽元素浮动与自适应元素不浮动导致浏览器兼容性不好</li><li>如果右侧容器存在子级元素，为子级元素清除浮动之后，整个页面布局会乱掉 </li></ol><p>**</p><pre><code class="html">    &lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .parent &#123;        background-color: #eee;    &#125;    .left,    .right &#123;        height: 500px;    &#125;     .left &#123;        width:300px;        background-color: #00ffff;        /* 脱离文档流 */        float: left;    &#125;    .right &#123;        /* 自动撑满父盒子 宽度默认父盒子宽度的100% */        background-color: #ff0000;        /*  */        margin-left: 300px;    &#125;    /* .inner &#123;        height: 200px;        background-color: #00ff00;        /*清除浮动  */      /*  clear: both;    &#125; */    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt; 左： 定宽&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右： 自适应          &lt;!-- &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; --&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>** 注：以下是代码优化 为自适应元素添加父级元素并设置浮动  没有解决高耦合的问题 **</p><pre><code class="html">  &lt;style&gt;        * &#123;            margin: 0;            padding: 0;        &#125;        .parent &#123;            background-color: #eee;        &#125;        .left,        .right &#123;            height: 200px;        &#125;         .left &#123;            width:300px;            background-color: #00ffff;            /* 脱离文档流 */            float: left;            /* margin-left: -100%; */            /* 提高显示层级 */            position: relative;        &#125;        .right-fix &#123;            /* 由于设置浮动，默认宽度为 0 */            /* 由于设置 父级元素 的 width: 100%;所以 宽度不够 而掉到第二行*/            width: 100%;            /* 向左移动 此时覆盖掉 左侧*/            margin-left: -300px;            float: left;            background-color: #000000;        &#125;        .right &#123;            /* 自动撑满父盒子 宽度默认父盒子宽度的100% */               margin-left: 300px;             /* padding-left: 300px; */            background-color: #ff0000;        &#125;        &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt; 左： 定宽&lt;/div&gt;        &lt;div class=&quot;right-fix&quot;&gt;            &lt;div class=&quot;right&quot;&gt; 右： 自适应&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="float-overflow-属性实现"><a href="#float-overflow-属性实现" class="headerlink" title="float + overflow 属性实现"></a>float + overflow 属性实现</h4><p>**  此方案的优缺点<br>优点：没有第一种解决方案中存在的问题<br>缺点：overflow 属性开启BFC模式的同时，也存在溢出隐藏，右列内容溢出的时候就会被隐藏 ，由于开启BFC模式，所以不存在第一种解决方案中的同级元素要浮动都浮动的浏览器兼容性问题<br>**</p><pre><code class="html">  &lt;style&gt;    * &#123;       margin: 0;       padding: 0;     &#125;    .parent &#123;        background-color: #eee;        height: 500px;    &#125;    .left,     .right &#123;        height: 300px;    &#125;    .left &#123;        width: 300px;        background-color: #00ffff;        float: left;    &#125;    .right &#123;        background-color: #ff0000;        /*             overflow 属性：             - hidden 溢出隐藏 和 开启BFC模式，当前元素的内部环境与外界完全隔离         */        overflow: hidden;    &#125;    &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt; 左： 左对齐&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右：自适应&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="使用-display-属性的-table-相关值"><a href="#使用-display-属性的-table-相关值" class="headerlink" title="使用 display 属性的 table 相关值"></a>使用 display 属性的 table 相关值</h4><p>**  此方案的优缺点<br>优点：浏览器的兼容性比较好<br>缺点：将所有元素的 display 属性设置为 table 相关值，受到相应制约，同时也需要重新设置表格的特性，比如双边框、文本内容等问题<br>**</p><pre><code class="html">&lt;style&gt;    * &#123;       margin: 0;       padding: 0;     &#125;    .parent &#123;        background-color: #eee;        height: 500px;        /* 表格的单元格的宽度会自动分配，左侧固定，右侧则自适应 */        display: table;        /*             table-layout 属性 用来显示表格单元格、行、列的算法规则            - automatic: 默认，列宽度有单元格内容设定            - fixed: 列宽由表格宽度和列宽度设定            - inherit： 规定应该从父元素继承 table-layout 属性的值          */        table-layout: fixed;        width: 100%;    &#125;    .left,     .right &#123;        height: 300px;        display: table-cell;    &#125;    .left &#123;        width: 300px;        background-color: #00ffff;    &#125;    .right &#123;        background-color: #ff0000;    &#125;        &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt; 左： 左对齐&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右：自适应&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="什么是三列布局"><a href="#什么是三列布局" class="headerlink" title="什么是三列布局"></a>什么是三列布局</h3><p>—— 两列定宽且相邻，另外一列宽度自适应</p><h3 id="三列布局的实现"><a href="#三列布局的实现" class="headerlink" title="三列布局的实现"></a>三列布局的实现</h3><p>实现方式与两列布局实现方式类似</p><h4 id="float-margin-属性实现-1"><a href="#float-margin-属性实现-1" class="headerlink" title="float + margin 属性实现"></a>float + margin 属性实现</h4><pre><code class="html">&lt;style&gt;    * &#123;       margin: 0;       padding: 0;     &#125;    .parent &#123;        background-color: #eee;        height: 500px;    &#125;    .left,    .center,     .right &#123;        height: 300px;    &#125;    .left &#123;        width: 300px;        background-color: #00ffff;        /*  */        float: left;    &#125;    .center &#123;        width: 300px;        background-color: #ffff00;        float: left;    &#125;    .right &#123;        background-color: #ff0000;        margin-left: 600px;    &#125;        &lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt; 左： 定宽&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt; 中：定宽 &lt;/div&gt;        &lt;div class=&quot;right&quot;&gt; 右：自适应&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="float-overflow-属性实现-1"><a href="#float-overflow-属性实现-1" class="headerlink" title="float + overflow 属性实现"></a>float + overflow 属性实现</h4><pre><code class="html">略，参考两列布局</code></pre><h4 id="使用-display-属性的-table-相关值-1"><a href="#使用-display-属性的-table-相关值-1" class="headerlink" title="使用 display 属性的 table 相关值"></a>使用 display 属性的 table 相关值</h4><pre><code class="html">略，参考两列布局</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布局总结</title>
    <link href="/alwaysblog/post/3630208258/"/>
    <url>/alwaysblog/post/3630208258/</url>
    
    <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h4><span id="more"></span><ul><li>水平居中布局</li><li>垂直居中布局</li><li>居中布局（ 水平 + 垂直 ）<h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4></li><li>两列布局</li><li>三列布局</li><li>CSS 3 多列布局<h4 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h4></li><li>圣杯布局</li><li>双飞翼布局<h4 id="全屏布局"><a href="#全屏布局" class="headerlink" title="全屏布局"></a>全屏布局</h4><h4 id="未涉及的布局"><a href="#未涉及的布局" class="headerlink" title="未涉及的布局"></a>未涉及的布局</h4></li><li>网格布局</li><li>弹性盒子布局 CSS3 </li></ul><p>** 没有任何一种布局方式是全优的，在实际应用中根据实际情况选择最合理的布局方式** </p>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等分布局与等高布局</title>
    <link href="/alwaysblog/post/1051762681/"/>
    <url>/alwaysblog/post/1051762681/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是等分布局"><a href="#什么是等分布局" class="headerlink" title="什么是等分布局"></a>什么是等分布局</h3><p>—— 一行被分成若干列，每一列的宽度相同</p><span id="more"></span><p>[ 实现方式 ]</p><ul><li><p>float 属性实现等分布局效果</p></li><li><p>display 属性的值有关 table 的值实现</p><h4 id="float-属性实现等分布局效果"><a href="#float-属性实现等分布局效果" class="headerlink" title="float 属性实现等分布局效果"></a>float 属性实现等分布局效果</h4><pre><code class="html">&lt;style&gt;      /*        *          *       */  * &#123;     margin: 0;     padding: 0;   &#125;  .parent &#123;      background-color: #eee;  &#125;  .column1,  .column2,  .column3,  .column5,  .column6 &#123;      height: 500px;      width: 20%;      float: left;      &#125;  .column2 &#123;      background-color: #ff66ff;  &#125;  .column3 &#123;      background-color: #00ffff;  &#125;  .column1 &#123;      background-color: #ffff00;  &#125;  .column5 &#123;      background-color: #ff0000;  &#125;  .column6 &#123;      background-color: #00ff00;  &#125;  &lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;parent&quot;&gt;      &lt;div class=&quot;column1&quot;&gt;1&lt;/div&gt;      &lt;div class=&quot;column2&quot;&gt;2&lt;/div&gt;      &lt;div class=&quot;column3&quot;&gt;3&lt;/div&gt;      &lt;div class=&quot;column5&quot;&gt;5&lt;/div&gt;      &lt;div class=&quot;column6&quot;&gt;6&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="display-属性的值有关-table-的值实现"><a href="#display-属性的值有关-table-的值实现" class="headerlink" title="display 属性的值有关 table 的值实现"></a>display 属性的值有关 table 的值实现</h4><pre><code class="html">&lt;style&gt;  /*    *    *     *   */  * &#123;     margin: 0;     padding: 0;   &#125;  .parent &#123;      background-color: #eee;      width: 100%;      /* &lt;table&gt; 元素 */      display: table;  &#125;  .column1,  .column2,  .column3,  .column5,  .column6 &#123;      height: 500px;      /* &lt;td&gt; 元素 */      display: table-cell;  &#125;  .column2 &#123;      background-color: #ff66ff;  &#125;  .column3 &#123;      background-color: #00ffff;  &#125;  .column1 &#123;      background-color: #ffff00;  &#125;  .column5 &#123;      background-color: #ff0000;  &#125;  .column6 &#123;      background-color: #00ff00;  &#125;  &lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;parent&quot;&gt;      &lt;div class=&quot;column1&quot;&gt;1&lt;/div&gt;      &lt;div class=&quot;column2&quot;&gt;2&lt;/div&gt;      &lt;div class=&quot;column3&quot;&gt;3&lt;/div&gt;      &lt;div class=&quot;column5&quot;&gt;5&lt;/div&gt;      &lt;div class=&quot;column6&quot;&gt;6&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="等分布局的空白间距"><a href="#等分布局的空白间距" class="headerlink" title="等分布局的空白间距"></a>等分布局的空白间距</h4><p>[ 方法一 代码修改 ]</p><pre><code class="html">&lt;style&gt;  /*    * 间距 + 容器宽度 = (间距 + 列宽度) * N列数    *     *   */  * &#123;     margin: 0;     padding: 0;   &#125;  .parent-fix &#123;      /* 溢出隐藏 */      overflow: hidden;  &#125;  .parent &#123;      background-color: #eee;      /* 解决高度塌陷 */      overflow: hidden;      /* height: 500px; */      margin-left: -20px;  &#125;  .column1,  .column2,  .column3,  .column5,  .column6 &#123;      height: 500px;      width: 20%;      float: left;      padding-left: 20px;      /* margin-left: 20px;  */       /*          box-sizing 属性          */      box-sizing: border-box;  &#125;  .column2 .inner &#123;      background-color: #ff66ff;  &#125;  .column3 .inner &#123;      background-color: #00ffff;  &#125;  .column1 .inner &#123;      background-color: #ffff00;  &#125;  .column5 .inner &#123;      background-color: #ff0000;  &#125;  .column6 .inner &#123;      background-color: #00ff00;  &#125;  .inner &#123;      height: 500px;  &#125;  &lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;parent-fix&quot;&gt;      &lt;div class=&quot;parent&quot;&gt;          &lt;div class=&quot;column1&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column2&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column3&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column5&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column6&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;      &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>[ 方法二 代码修改 ]</p><pre><code class="html">  &lt;style&gt;  /*    * 实际开发中 parent 元素 width 的值是有一个范围   * 在此案例中 parent-fix 的宽度为  1369px - 20px   *   */  * &#123;     margin: 0;     padding: 0;   &#125;  .parent-fix &#123;      overflow: hidden;  &#125;  .parent &#123;      background-color: #eee;      width: 1369px;      /* &lt;table&gt; 元素 */      display: table;      margin-left: -20px;  &#125;  .column1,  .column2,  .column3,  .column5,  .column6 &#123;      height: 500px;      /* &lt;td&gt; 元素 */      display: table-cell;      padding-left: 20px;      box-sizing: border-box;  &#125;  .column2 .inner &#123;      background-color: #ff66ff;  &#125;  .column3 .inner &#123;      background-color: #00ffff;  &#125;  .column1 .inner &#123;      background-color: #ffff00;  &#125;  .column5 .inner &#123;      background-color: #ff0000;  &#125;  .column6 .inner &#123;      background-color: #00ff00;  &#125;  .inner &#123;      height: 500px;  &#125;    &lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;parent-fix&quot;&gt;      &lt;div class=&quot;parent&quot;&gt;          &lt;div class=&quot;column1&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column2&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column3&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column5&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;          &lt;div class=&quot;column6&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;      &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="什么是等高布局"><a href="#什么是等高布局" class="headerlink" title="什么是等高布局"></a>什么是等高布局</h3><p>—— 一行被分成若干列，每一列的高度相同<br>[ 实现方式 ]</p></li><li><p>display 属性的值有关 table 的值实现</p></li><li><p>padding + margin 实现等高布局效果</p><h4 id="display-属性的值有关-table-的值实现-1"><a href="#display-属性的值有关-table-的值实现-1" class="headerlink" title="display 属性的值有关 table 的值实现"></a>display 属性的值有关 table 的值实现</h4><p>```html</p><style>  /*    * 表格中的单元格 默认是等高的，无论内容多少   *    *   */  * {     margin: 0;     padding: 0;   }  .parent {      background-color: #eee;      /* <table> 元素 */      display: table;      table-layout: fixed;  }  .left,  .right {      width: 300px;      /* <td> 元素 */      display: table-cell;  }  .left {      background-color: #ffff00;  }  .right {      background-color: #ff66ff;  }  </style><body>  <div class="parent">      <div class="left">imooc</div>      <div class="right">Lorem ipsum dolor sit amet consectetur adipisicing elit. Quis repudiandae dolore minus maxime ex quos consectetur cumque autem iure vero corrupti at est cupiditate, praesentium dolorem itaque doloremque soluta veritatis!</div>  </div></body></li></ul><pre><code>#### padding + margin 实现等高布局效果```html    &lt;style&gt;    /*      *      *      *     */    * &#123;       margin: 0;       padding: 0;     &#125;    .parent &#123;        background-color: #eee;        /* 解决高度塌陷 */        overflow: hidden;    &#125;    .left,    .right &#123;        width: 300px;        float: left;        padding-bottom: 99999px;         margin-bottom: -99999px;       &#125;    .left &#123;        background-color: #ffff00;    &#125;    .right &#123;        background-color: #ff66ff;    &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;left&quot;&gt;imooc&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Quis repudiandae dolore minus maxime ex quos consectetur cumque autem iure vero corrupti at est cupiditate, praesentium dolorem itaque doloremque soluta veritatis!&lt;/div&gt;        &lt;div class=&quot;left&quot;&gt;imooc&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Quis repudiandae dolore minus maxime ex quos consectetur cumque autem iure vero corrupti at est cupiditate, praesentium dolorem itaque doloremque soluta veritatis!&lt;/div&gt;        &lt;div class=&quot;left&quot;&gt;imooc&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Quis repudiandae dolore minus maxime ex quos consectetur cumque autem iure vero corrupti at est cupiditate, praesentium dolorem itaque doloremque soluta veritatis!&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端领域</category>
      
      <category>小专栏</category>
      
      <category>布局方式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css 布局</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>